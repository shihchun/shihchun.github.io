[{"categories":null,"content":"It's a example","date":"2023-02-16","objectID":"/2023-02-16/","tags":null,"title":"MobaXterm Build EDK2","uri":"/2023-02-16/"},{"categories":null,"content":"\r092dc03dc7bd5b403aba8dbe8333acf5e99c9ae6ede8ce59a9181291e6e436c2\rmichael\r輸入過密碼直接點擊即可 文章部分內容受密碼保護： 在Build EDK2的時候遇到一個問題造成無法成功，造成nmake編譯器產生錯誤 env.bat :: set PYTHON_COMMAND=C:\\Python27\\python.exe set PACKAGES_PATH=C:\\source\\edk2-platforms;C:\\source\\edk2 set PYTHON3_ENABLE=TRUE set PYTHON_HOME=C:\\Python311 set NASM_PREFIX=C:\\Program Files\\NASM\\ :: set CYGWIN_HOME=C:\\ProgramData\\chocolatey\\lib\\Cygwin set CYGWIN_HOME=C:\\source\\edk2\\BaseTools\\Bin\\CYGWIN_NT-5.1-i686 set CLANG_BIN=C:\\ProgramData\\chocolatey\\lib\\mingw\\tools\\install\\mingw64\\bin :: if X86 IA32 put IASL exe files to C:\\ASL\\ .\\edk2\\edksetup.bat Rebuild \u0026\u0026 .\\edk2\\edksetup.bat VS2019 Fig\r主要原因是因爲echo使用了MobaXterm的echo，只要把slash\\bin從環境變量中刪除即可正確的Build Code了 :: C:\\Users\\michael\\AppData\\Roaming\\MobaXterm\\slash\\bin :: %APPDATA%\\MobaXterm\\slash\\bin C:\\Users\\michael\\AppData\\Roaming\\MobaXterm\\slash\\bin\\echo. ","date":"2023-02-16","objectID":"/2023-02-16/:0:0","tags":null,"title":"MobaXterm Build EDK2","uri":"/2023-02-16/"},{"categories":null,"content":"It's a example","date":"2022-12-16","objectID":"/2022-12-16/","tags":null,"title":"Build EDK source code","uri":"/2022-12-16/"},{"categories":null,"content":"Ubuntu 18.04 :: disable Right Click show more on Win11 reg add HKCU\\Software\\Classes\\CLSID\\{86ca1aa0-34aa-4e8b-a509-50c905bae2a2}\\InprocServer32 /ve /d \"\" /f :: enable Right Click show more on Win11 reg delete \"HKEY_CURRENT_USER\\Software\\Classes\\CLSID\\{86ca1aa0-34aa-4e8b-a509-50c905bae2a2}\" /f​ :: enable wsl dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart :: enable vm dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart :: set to wsl version 2 wsl --set-default-version 2 # 設定完密碼之後設定root 密碼 passwd root ## Windows Store 安裝Ubuntu 18.04 choco install vcxsrv # for x11 display # or choco install mobaxterm # x11 display 照着ARM-Developer步驟建立EDK2環境 sudo apt install python python3 python3-distutils uuid-dev build-essential bison flex # for emulator VM sudo apt-get install qemu qemu-system-x86 # for X64 build sudo apt-get install # sudo apt-get install nasm # update a version # https://www.linuxfromscratch.org/blfs/view/svn/general/nasm.html wget https://www.nasm.us/pub/nasm/releasebuilds/2.16.01/nasm-2.16.01.tar.xz # build source # x11-apps and some header for edk2 build x11 display sudo apt-get install x11-apps export DISPLAY=127.0.0.1:0 # for x11 display port cd source export WORKSPACE=$PWD git clone https://github.com/tianocore/edk2-platforms.git git clone https://github.com/acpica/acpica.git git clone https://github.com/tianocore/edk2.git cd edk2 git tag -l git checkout -f --recurse-submodules tags/release_tag git submodule update --init cd $WORKSPACE # equal cd ../ ","date":"2022-12-16","objectID":"/2022-12-16/:1:0","tags":null,"title":"Build EDK source code","uri":"/2022-12-16/"},{"categories":null,"content":"Build ACPICA for ARM ## arm toolchain mkdir $WORKSPACE/toolchain cd $WORKSPACE/toolchain wget https://armkeil.blob.core.windows.net/developer/Files/downloads/gnu-a/9.2-2019.12/binrel/gcc-arm-9.2-2019.12-x86_64-aarch64-none-elf.tar.xz tar xvf gcc-arm-9.2-2019.12-x86_64-aarch64-none-elf.tar.xz cd $WORKSPACE make -C $WORKSPACE/acpica make: Entering directory '/mnt/c/source/acpica' make[1]: Entering directory '/mnt/c/source/acpica/generate/unix/acpibin' obj/acpibin ../../../source/tools/acpibin/abcompare.c In file included from ../../../source/include/actbl.h:549:0, from ../../../source/include/acpi.h:169, from ../../../source/tools/acpibin/acpibin.h:152, from ../../../source/tools/acpibin/abcompare.c:152: ../../../source/include/actbl2.h:1553:29: error: flexible array member in a struct with no named members UINT8 OemData[]; ^~~~~~~ ../Makefile.rules:19: recipe for target 'obj/abcompare.o' failed make[1]: *** [obj/abcompare.o] Error 1 make[1]: Leaving directory '/mnt/c/source/acpica/generate/unix/acpibin' generate/unix/Makefile.common:7: recipe for target 'acpibin' failed make: *** [acpibin] Error 2 make: Leaving directory '/mnt/c/source/acpica' # build 不過退版本 cd acpica git log -3 --oneline git checkout -f 9166abc0d make -C . cd $WORKSPACE ","date":"2022-12-16","objectID":"/2022-12-16/:1:1","tags":null,"title":"Build EDK source code","uri":"/2022-12-16/"},{"categories":null,"content":"Build EDK export GCC5_AARCH64_PREFIX=$WORKSPACE/toolchain/gcc-arm-9.2-2019.12-x86_64-aarch64-none-elf/bin/aarch64-none-elf- export PACKAGES_PATH=$WORKSPACE/edk2:$WORKSPACE/edk2-platforms export IASL_PREFIX=$WORKSPACE/acpica/generate/unix/bin/ export PYTHON_COMMAND=/usr/bin/python export PYTHON_COMMAND=/usr/bin/python3 source edk2/edksetup.sh make -C edk2/BaseTools # 失敗可以看 git status, checkout 回去再試一次看看 確定都Build成功後可以開始建立環境build code env.sh export WORKSPACE=$PWD export GCC5_AARCH64_PREFIX=$WORKSPACE/toolchain/gcc-arm-9.2-2019.12-x86_64-aarch64-none-elf/bin/aarch64-none-elf- export PACKAGES_PATH=$WORKSPACE/edk2:$WORKSPACE/edk2-platforms export IASL_PREFIX=$WORKSPACE/acpica/generate/unix/bin/ export PYTHON_COMMAND=/usr/bin/python export PYTHON_COMMAND=/usr/bin/python3 source edk2/edksetup.sh rel.sh: build release rm -rf Build/OvmfX64/RELEASE_GCC5/X64/MdeModulePkg/Application/HelloWorld build -a X64 -t GCC5 -p edk2/OvmfPkg/OvmfPkgX64.dsc -b RELEASE # build -a X64 -t GCC5 -p edk2/OvmfPkg/OvmfPkgX64.dsc -b DEBUG # build -a X64 -t GCC5 -p edk2/OvmfPkg/OvmfPkgX64.dsc -b DEBUG -D DEBUG_ON_SERIAL_PORT qemu-system-x86_64 -bios Build/OvmfX64/RELEASE_GCC5/FV/OVMF.fd -M pc -m 10240 -cpu qemu64 -name UEFI -boot order=dc -hda fat:rw:Build/OvmfX64/RELEASE_GCC5/X64/MdeModulePkg/Application/HelloWorld/HelloWorld/OUTPUT -nographic # qemu-system-x86_64 -bios Build/OvmfX64/RELEASE_GCC5/FV/OVMF.fd -M pc -m 10240 -cpu qemu64 -vga cirrus -name UEFI -boot order=dc -hda fat:rw:Build/OvmfX64/RELEASE_GCC5/ -serial stdio # qemu-system-x86_64 -bios Build/OvmfX64/RELEASE_GCC5/FV/OVMF.fd -M pc -m 10240 -cpu qemu64 -vga cirrus -name UEFI -boot order=dc -hda fat:rw:Build/OvmfX64/DEBUG_GCC5/X64/MdeModulePkg/Application/HelloWorld/HelloWorld/OUTPUT -serial stdio # qemu-system-x86_64 -bios Build/OvmfX64/RELEASE_GCC5/FV/OVMF.fd -M pc -m 10240 -cpu qemu64 -vga cirrus -name UEFI -boot order=dc -hda fat:rw:Build/OvmfX64/RELEASE_GCC5/X64/MdeModulePkg/Application/HelloWorld/HelloWorld/OUTPUT -serial stdio # qemu-system-x86_64 -bios Build/OvmfX64/RELEASE_GCC5/FV/OVMF.fd -M pc -m 10240 -cpu qemu64 -vga cirrus -name UEFI -boot order=dc -hda fat:rw:Build/OvmfX64/RELEASE_GCC5/ -serial stdio deg.sh: build debug build -a X64 -t GCC5 -p edk2/OvmfPkg/OvmfPkgX64.dsc -b DEBUG -D DEBUG_ON_SERIAL_PORT qemu-system-x86_64 -bios Build/OvmfX64/RELEASE_GCC5/FV/OVMF.fd -M pc -m 10240 -cpu qemu64 -vga cirrus -name UEFI -boot order=dc -hda fat:rw:Build/OvmfX64/DEBUG_GCC5/X64/MdeModulePkg/Application/HelloWorld/HelloWorld/OUTPUT -nographic -serial stdio ","date":"2022-12-16","objectID":"/2022-12-16/:1:2","tags":null,"title":"Build EDK source code","uri":"/2022-12-16/"},{"categories":null,"content":"Windows choco install mingw qemu nasm choco install visualstudio2019community mkdir source cd source git clone https://github.com/tianocore/edk2-platforms.git git clone https://github.com/acpica/acpica.git git clone https://github.com/tianocore/edk2.git cd edk2 git tag -l git checkout -f --recurse-submodules tags/release_tag git submodule update --init 修改Visual Studio建置環境 Fig\r安裝Python Fig\renv.bat :: remove mobaterm slash\\echo :: call setpath_moba.bat :: set PYTHON_COMMAND=C:\\Python27\\python.exe set PACKAGES_PATH=C:\\source\\edk2-platforms;C:\\source\\edk2 set PYTHON3_ENABLE=TRUE set PYTHON_HOME=C:\\Python311 set NASM_PREFIX=C:\\Program Files\\NASM\\ :: set CYGWIN_HOME=C:\\ProgramData\\chocolatey\\lib\\Cygwin set CYGWIN_HOME=C:\\source\\edk2\\BaseTools\\Bin\\CYGWIN_NT-5.1-i686 set CLANG_BIN=C:\\ProgramData\\chocolatey\\lib\\mingw\\tools\\install\\mingw64\\bin :: if X86 IA32 put IASL exe files to C:\\ASL\\ .\\edk2\\edksetup.bat Rebuild \u0026\u0026 .\\edk2\\edksetup.bat VS2019 rel.bat :: build -a X64 -t VS2019 -p EmulatorPkg\\EmulatorPkg.dsc -b RELEASE call build -a X64 -t VS2019 -p OvmfPkg/OvmfPkgX64.dsc -b RELEASE echo Press to Emulate pause rem Get user input set /p strr=Load HelloWorld or not(Y/N): if %strr%==Y (echo HelloWorld PATH )else ( GOTO MODULE) call qemu-system-x86_64 -bios edk2\\Build\\OvmfX64\\RELEASE_VS2019\\FV\\OVMF.fd -hda fat:rw:edk2\\Build\\OvmfX64\\RELEASE_VS2019\\X64\\MdeModulePkg\\Application\\HelloWorld\\HelloWorld\\OUTPUT -nographic GOTO:EOF :MODULE call qemu-system-x86_64 -bios edk2\\Build\\OvmfX64\\RELEASE_VS2019\\FV\\OVMF.fd -hda fat:rw:edk2\\Build\\OvmfX64\\RELEASE_VS2019\\X64 -serial stdio GOTO:EOF ","date":"2022-12-16","objectID":"/2022-12-16/:2:0","tags":null,"title":"Build EDK source code","uri":"/2022-12-16/"},{"categories":null,"content":"Build Intel Board Package 查看，需要安裝FSP並加入環境變量build code，FSP之後再來研究 C:\\source\\edk2-platforms\\Platform\\Intel\\Readme.md cd source env.bat ## env.bat add one line set PACKAGES_PATH=%PACKAGES_PATH%;c:\\source\\edk2-platforms\\Platform\\Intel;c:\\source\\edk2-platforms\\Silicon\\Intel;c:\\source\\edk2-platforms\\Features\\Intel ## 文件中寫 build -p BoardModulePkg/BoardModulePkg.dsc -a IA32 -a X64 # 修改爲 build -t VS2019 -p BoardModulePkg/BoardModulePkg.dsc -a X64 ","date":"2022-12-16","objectID":"/2022-12-16/:3:0","tags":null,"title":"Build EDK source code","uri":"/2022-12-16/"},{"categories":null,"content":"It's a example","date":"2022-09-15","objectID":"/2022-09-15/","tags":["clang"],"title":"C語言筆記","uri":"/2022-09-15/"},{"categories":null,"content":"Day1 ","date":"2022-09-15","objectID":"/2022-09-15/:1:0","tags":["clang"],"title":"C語言筆記","uri":"/2022-09-15/"},{"categories":null,"content":"GCC編譯過程 C語言編譯過程會按照順序經過 預處理（define include替換後給編譯器處理），不屬於關鍵字 gcc -E -o 編譯 gcc -S -o 組譯（匯編） gcc -c -o 鏈接 連接*.o的binary檔案 gcc -o 產生可執行檔案 gcc -v -o build test1.c Using built-in specs. COLLECT_GCC=gcc COLLECT_LTO_WRAPPER=/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/lto-wrapper Target: x86_64-pc-linux-gnu Configured with: /build/gcc/src/gcc/configure --prefix=/usr --libdir=/usr/lib --libexecdir=/usr/lib --mandir=/usr/share/man --infodir=/usr/share/info --with-bugurl=https://bugs.archlinux.org/ --enable-languages=c,c++,ada,fortran,go,lto,objc,obj-c++,d --with-isl --with-linker-hash-style=gnu --with-system-zlib --enable-__cxa_atexit --enable-cet=auto --enable-checking=release --enable-clocale=gnu --enable-default-pie --enable-default-ssp --enable-gnu-indirect-function --enable-gnu-unique-object --enable-install-libiberty --enable-linker-build-id --enable-lto --enable-multilib --enable-plugin --enable-shared --enable-threads=posix --disable-libssp --disable-libstdcxx-pch --disable-libunwind-exceptions --disable-werror gdc_include_dir=/usr/include/dlang/gdc Thread model: posix Supported LTO compression algorithms: zlib zstd gcc version 11.1.0 (GCC) COLLECT_GCC_OPTIONS='-v' '-o' 'build' '-mtune=generic' '-march=x86-64' '-dumpdir' 'build-' /usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/cc1 -quiet -v test1.c -quiet -dumpdir build- -dumpbase test1.c -dumpbase-ext .c -mtune=generic -march=x86-64 -version -o /tmp/ccvuBrUn.s GNU C17 (GCC) version 11.1.0 (x86_64-pc-linux-gnu) compiled by GNU C version 11.1.0, GMP version 6.2.1, MPFR version 4.1.0-p13, MPC version 1.2.1, isl version isl-0.24-GMP GGC heuristics: --param ggc-min-expand=100 --param ggc-min-heapsize=131072 ignoring nonexistent directory \"/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/../../../../x86_64-pc-linux-gnu/include\" #include \"...\" search starts here: #include \u003c...\u003e search starts here: /usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/include /usr/local/include /usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/include-fixed /usr/include End of search list. GNU C17 (GCC) version 11.1.0 (x86_64-pc-linux-gnu) compiled by GNU C version 11.1.0, GMP version 6.2.1, MPFR version 4.1.0-p13, MPC version 1.2.1, isl version isl-0.24-GMP GGC heuristics: --param ggc-min-expand=100 --param ggc-min-heapsize=131072 Compiler executable checksum: ec1bc319e19ef4dd2d241e66d95d4739 COLLECT_GCC_OPTIONS='-v' '-o' 'build' '-mtune=generic' '-march=x86-64' '-dumpdir' 'build-' as -v --64 -o /tmp/ccYy1xpJ.o /tmp/ccvuBrUn.s GNU assembler version 2.36.1 (x86_64-pc-linux-gnu) using BFD version (GNU Binutils) 2.36.1 COMPILER_PATH=/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/:/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/:/usr/lib/gcc/x86_64-pc-linux-gnu/:/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/:/usr/lib/gcc/x86_64-pc-linux-gnu/ LIBRARY_PATH=/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/:/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/../../../../lib/:/lib/../lib/:/usr/lib/../lib/:/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/../../../:/lib/:/usr/lib/ COLLECT_GCC_OPTIONS='-v' '-o' 'build' '-mtune=generic' '-march=x86-64' '-dumpdir' 'build.' /usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/collect2 -plugin /usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/liblto_plugin.so -plugin-opt=/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/lto-wrapper -plugin-opt=-fresolution=/tmp/cciGeuNv.res -plugin-opt=-pass-through=-lgcc -plugin-opt=-pass-through=-lgcc_s -plugin-opt=-pass-through=-lc -plugin-opt=-pass-through=-lgcc -plugin-opt=-pass-through=-lgcc_s --build-id --eh-frame-hdr --hash-style=gnu -m elf_x86_64 -dynamic-linker /lib64/ld-linux-x86-64.so.2 -pie -o build /usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/../../../../lib/Scrt1.o /usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/../../../../lib/crti.o /usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/crtbeginS.o -L/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0 -L/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/../../../../lib -L/lib/../lib -L/usr/lib/../lib -L/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/../../.. /tmp/ccYy1xpJ.o -lgcc --push-state --as-needed -lgcc_s --pop-state -lc -lgcc --push-state --as-ne","date":"2022-09-15","objectID":"/2022-09-15/:1:1","tags":["clang"],"title":"C語言筆記","uri":"/2022-09-15/"},{"categories":null,"content":"編譯文件範例 gcc -S -o a.s test1.c # 編譯 a.s我組合語言檔案 ls a.s test1.c gcc -c -o a.o test1.c # 組譯 a.o爲二進制檔案 ls a.s a.o test1.c test1.c檔案如下： #include \u003cstdio.h\u003e int main(){ int a[10]; for(int i=0;i\u003c10;i++) {a[i]=9-i;} for(int i=0; i\u003c10;i++){a[i]=a[a[i]];} printf(\"a[8]: %d\",a[8]); } a.s檔案如下： .file \"test1.c\" .text .section .rodata .LC0: .string \"a[8]: %d\" .text .globl main .type main, @function main: .LFB0: .cfi_startproc pushq %rbp .cfi_def_cfa_offset 16 .cfi_offset 6, -16 movq %rsp, %rbp .cfi_def_cfa_register 6 subq $64, %rsp movq %fs:40, %rax movq %rax, -8(%rbp) xorl %eax, %eax movl $0, -56(%rbp) jmp .L2 .L3: movl $9, %eax subl -56(%rbp), %eax movl %eax, %edx movl -56(%rbp), %eax cltq movl %edx, -48(%rbp,%rax,4) addl $1, -56(%rbp) .L2: cmpl $9, -56(%rbp) jle .L3 movl $0, -52(%rbp) jmp .L4 .L5: movl -52(%rbp), %eax cltq movl -48(%rbp,%rax,4), %eax cltq movl -48(%rbp,%rax,4), %edx movl -52(%rbp), %eax cltq movl %edx, -48(%rbp,%rax,4) addl $1, -52(%rbp) .L4: cmpl $9, -52(%rbp) jle .L5 movl -16(%rbp), %eax movl %eax, %esi leaq .LC0(%rip), %rax movq %rax, %rdi movl $0, %eax call printf@PLT movl $0, %eax movq -8(%rbp), %rdx subq %fs:40, %rdx je .L7 call __stack_chk_fail@PLT .L7: leave .cfi_def_cfa 7, 8 ret .cfi_endproc .LFE0: .size main, .-main .ident \"GCC: (GNU) 11.1.0\" .section .note.GNU-stack,\"\",@progbits ","date":"2022-09-15","objectID":"/2022-09-15/:1:2","tags":["clang"],"title":"C語言筆記","uri":"/2022-09-15/"},{"categories":null,"content":"表頭預處理錯誤問題 gcc -I \u003c\u003e尋找系統環境變量中的目錄位置的檔案 #include \u003cstdio.h\u003e #include \"stdio.h\" 若新增一個abc.h的檔案在./inc目錄之下， 可以使用gcc -I ./inc -o build test1.c ","date":"2022-09-15","objectID":"/2022-09-15/:1:3","tags":["clang"],"title":"C語言筆記","uri":"/2022-09-15/"},{"categories":null,"content":"鏈接錯誤 #include \u003cstdio.h\u003e void fun(void); int main(){ fun(); return 0; } gcc -o build test1.c /usr/sbin/ld: /tmp/ccWBLXSg.o: in function `main': test1.c:(.text+0x5): undefined reference to `fun' collect2: error: ld returned 1 exit status 修改爲 #include \u003cstdio.h\u003e void fun(void){} int main(){ fun(); return 0; } ","date":"2022-09-15","objectID":"/2022-09-15/:1:4","tags":["clang"],"title":"C語言筆記","uri":"/2022-09-15/"},{"categories":null,"content":"多檔案編譯 直接生成 gcc -o build a.c b.c gcc -I ./inc -o build a.c b.c 生成二進制檔案後，重新進行鏈接 gcc -c -I ./inc -o a.o a.c gcc -c -I ./inc -o b.o b.c gcc -o build a.o b.o ","date":"2022-09-15","objectID":"/2022-09-15/:1:5","tags":["clang"],"title":"C語言筆記","uri":"/2022-09-15/"},{"categories":null,"content":"編譯錯誤 語法問題 ","date":"2022-09-15","objectID":"/2022-09-15/:1:6","tags":["clang"],"title":"C語言筆記","uri":"/2022-09-15/"},{"categories":null,"content":"預處理撰寫 預處理主要有#include、#define、系統預定義宏（FUNCTION、LINE、FILE）、條件預處理（#ifdef #else #endif） 其中#include爲標頭檔案文件位置，\u003c\u003e表示爲環境變量中的名字，\"\"中表示爲當前目錄的位置 #define爲預處理器指示詞，可建立類似函式的宏(宏函數)，需要注意，儘量以大寫字母表示，安全起見在運算上加入() Ex:在預處理中需記得加入掛號，如下例子中，若無加入掛號ABx5會爲5+3x5並非我們想要的答案 #include \u003cstdio.h\u003e #define AB 5+3 #define ABC (5+3) #define ABCD(x) (5+x) int main(){ printf(\"The %d\\n\",AB*5); printf(\"The %d\\n\",ABC*5); printf(\"The %d\\n\",ABCD(5)*5); printf(\"__FUNCTION__:%s\\n__LINE__:%d\\n__FILE__:%s\",__FUNCTION__,__LINE__,__FILE__); //這裏LINE 10 return 0; } gcc -o build test1.c ./build The 20 The 40 The 50 __FUNCTION__:main __LINE__:10 __FILE__:test1.c% 條件預處理（#ifdef #else #endif） gcc -D 方便程式碼測試管理使用，避免大量修改而使用的功能 使用gcc -D ABC === #define ABC #include \u003cstdio.h\u003e // #define ABC int main(){ #ifdef ABC printf(\"====%s====:%d\\n\",__FILE__,__LINE__); printf(\"%s 函數執行\\n\",__FUNCTION__); #endif printf(\"hello world!\"); return 0; } gcc -o build test1.c \u0026\u0026 ./build hello world! gcc -D ABC -o build test1.c \u0026\u0026 ./build ====test1.c====:4 main 函數執行 hello world!% gcc -DABC -o build test1.c \u0026\u0026 ./build ====test1.c====:4 main 函數執行 hello world!% 宏展開 透過宏展開可以簡化名稱定義，使得撰寫更加方便，在Linux Kernel內核編程上也是尤爲常見，通常用來囊括一些相關訊息使用 # 字符串化 ## 連接符號 #include \u003cstdio.h\u003e #define ABC(x) #x #define DAY(x) myday##x int main(){ int myday1 = 10; int myday2 = 20; printf(ABC(ab\\n)); // 字符串化 ABC爲ab 需要\\n換行 printf(ABC(ab)); printf(\"the day is %d\\n\", DAY(1)); printf(\"the day2 is %d\\n\", DAY(2)); return 0; } gcc -o build test1.c \u0026\u0026 ./build ab abthe day is 10 the day2 is 20 Ex：如下程式便是此定義的衍生使用 #define err(formajt, arg...) printk(KERN_ERR \"%s: \" format, MY_NAME, ## arg) #define info(formajt, arg...) printk(KERN_INFO \"%s: \" format, MY_NAME, ## arg) #define warn(formajt, arg...) printk(KERN_WARNING \"%s: \" format, MY_NAME, ## arg) #define ADM8211_SRAM(x) (priv-\u003epdev-\u003erevision \u003c ADM8211_REV_BA ? \\ ADM8211_SRAM_A_ ## x: ADM8211_SRAM_B_ ## x) #define ADM8211_SRAM_INDIV_KEY 0x0000 #define ADM8211_SRAM_A_SHARE_KEY 0x0160 #define ADM8211_SRAM_B_SHARE_KEY 0x00c0 #define ADM8211_SRAM_A_SSID 0x0180 #define ADM8211_SRAM_B_SSID 0x00d4 #define ADM8211_SRAM_SSID ADM8211_SRAM(SSID) ","date":"2022-09-15","objectID":"/2022-09-15/:1:7","tags":["clang"],"title":"C語言筆記","uri":"/2022-09-15/"},{"categories":null,"content":"Day2 ","date":"2022-09-15","objectID":"/2022-09-15/:2:0","tags":["clang"],"title":"C語言筆記","uri":"/2022-09-15/"},{"categories":null,"content":"C語言關鍵字 C語言常見的32個關鍵字有介紹，簡略概括有，資料形別、自定義數據類型（enum枚舉、typedef、struct、union等等）、邏輯流程判斷式、類型修飾符號等等 char、int、long、short、unsigned、signed、float、double、void stuct、union、enum、typedef sizeof、return if、else switch、case、default do、while、for continue、break、go auto、register、static、const、extern、volatile ","date":"2022-09-15","objectID":"/2022-09-15/:2:1","tags":["clang"],"title":"C語言筆記","uri":"/2022-09-15/"},{"categories":null,"content":"return 函數定義後返回而已 ","date":"2022-09-15","objectID":"/2022-09-15/:2:2","tags":["clang"],"title":"C語言筆記","uri":"/2022-09-15/"},{"categories":null,"content":"sizeof sizeof()存在()容易被誤認爲函數，但是實際上在編譯過程中爲關鍵字，主要辨識 功能上主要查詢變量記憶體儲存容量的空間大小，沒什麼好說的 #include \u003cstdio.h\u003e int main(){ int a; printf(\"int sizeof %lu\\n\",sizeof a); // %lu無符號的返回詞 printf(\"int sizeof %d\\n\",sizeof(a)); float b; printf(\"float sizeof %d\\n\",sizeof(b)); double c; printf(\"double sizeof %d\\n\",sizeof(c)); char d; printf(\"char sizeof %d\\n\",sizeof(d)); long e; printf(\"long sizeof %d\\n\",sizeof(e)); short f; printf(\"short sizeof %d\\n\",sizeof(f)); return 0; } int sizeof 4 int sizeof 4 float sizeof 4 double sizeof 8 char sizeof 1 long sizeof 8 short sizeof 2 ","date":"2022-09-15","objectID":"/2022-09-15/:2:3","tags":["clang"],"title":"C語言筆記","uri":"/2022-09-15/"},{"categories":null,"content":"char char爲位元操作的的最小單位sizeof爲1byte，1byte=8bits=2^8可以記錄256個狀態，在操作上需要注意最大範圍，當Overflow的問題發生的時候，需對溢出位元進行額外處理 char buffer[32]; #include \u003cstdio.h\u003e int main(){ char a=0; printf(\"char sizeof %lu\\n\",sizeof a); // %lu無符號的返回詞 for (int i =0; i\u003c255; i+=1){ printf(\"%c\\n\",a); // 字串內容查詢ASCII表 printf(\"%d\\n\",a); a++; } return 0; } #include \u003cstdio.h\u003e int main(){ char a=255; printf(\"%c\\n\",a); // %lu無符號的返回詞 char a=256; // overflow return 0; } ","date":"2022-09-15","objectID":"/2022-09-15/:2:4","tags":["clang"],"title":"C語言筆記","uri":"/2022-09-15/"},{"categories":null,"content":"int 大小：根據編譯器來進行決定 編譯器最優處理大小，定義形別爲系統一個週期，能夠承受的最大處理單位 Ex：Signed value 32bit處理器爲 4 Byte大小=(2^31)-1= 2,147,483,647 dec 16bit處理器爲 2 Byte大小=(2^15)-1= 32,767 dec Ex：Unsinged 16bit=(2^16)-1=65,535dec….. 整型常量 在進行賦值的時候會根據編譯器一個週期可以處理的單位爲Limit進行賦值，若是2B系統的，200的地方最大只能寫到65535，32bit系統2147483647，其餘進制轉換此處不多介紹 char a = 200; ","date":"2022-09-15","objectID":"/2022-09-15/:2:5","tags":["clang"],"title":"C語言筆記","uri":"/2022-09-15/"},{"categories":null,"content":"long, short 特殊長度限制，此關鍵字需瞭解編譯器是否支援 ","date":"2022-09-15","objectID":"/2022-09-15/:2:6","tags":["clang"],"title":"C語言筆記","uri":"/2022-09-15/"},{"categories":null,"content":"unsigned, signed unsigned 用於數據採集 signed 用於數學意義的數值運算 #include \u003cstdio.h\u003e int main(){ char a=-1; //0xff =最大值255 signed value printf(\"%d\\n\",a); for(int i=0; i\u003c=7; i++){ // 右移8次 除2 a = a\u003e\u003e1; printf(\"%d\\n\",a); } unsigned char b=-1; // b = \"11111111\" printf(\"%d\\n\",b); for(int i=0; i\u003c=7; i++){ // 右移8次 除2 b=b\u003e\u003e1; printf(\"%d\\n\",b); } return 0; } -1 -1 -1 -1 -1 -1 -1 -1 -1 255 127 63 31 15 7 3 1 0 ","date":"2022-09-15","objectID":"/2022-09-15/:2:7","tags":["clang"],"title":"C語言筆記","uri":"/2022-09-15/"},{"categories":null,"content":"float, double 單精度 float 4B=32bit=-2^128~2^128 雙精度 double 8B=64bit=-2^1024~2^1024 ","date":"2022-09-15","objectID":"/2022-09-15/:2:8","tags":["clang"],"title":"C語言筆記","uri":"/2022-09-15/"},{"categories":null,"content":"void void（空的）表示不回傳 void main(){} ","date":"2022-09-15","objectID":"/2022-09-15/:2:9","tags":["clang"],"title":"C語言筆記","uri":"/2022-09-15/"},{"categories":null,"content":"自定義數據類型 在嵌入式系統撰寫中，爲了增加程式可讀性、以及未來編修的方便性，假設一個WDT看門狗計數器在系統中有四個暫存器位置的話，便可以使用自定義的方式完成定義並編輯。 Ex： Register Map Register Address R/W Description Reset Value WTCON 0xE270_0000 R/W Watchdog Timer Control Register 0x00008021 WTDAT 0xE270_0004 R/W Watchdog Timer Data Register 0x00008000 WTCNT 0xE270_0008 R/W Watchdog Timer Count Register 0x00008000 WTCLRINT 0xE270_000C W Watchdog Timer Interupt Clear Register - struct 在struct的創建過程中需注意其中元素的，擺放順序，不僅影響其表示意義，且也可能影響最後生成的結構大小 struct abc{ unsigned int a; unsigned int b; unsigned int c; }; struct abc myAbc; union union abc{ char a; unsigned int b; }; union abc myAbc; struct、union差別 stuct在創建過程中會在各個Variable中創建起始位址，而union則所有變量共用起始位址 假設在union創建如下，在修改b的同時a也會改變，屬於比較技巧性的處理手段 union abc{ char a; int b; } Struct VS Union\renum 枚舉 enumerate，用來取代#define的使用，增加程式可讀性 // #define MON 0 // #define TUE 1 // #define WED 2 enum week{ Monday=0,Tuesday=1,Wednesday=2, // 在無標識的情況按照順序進行編號 Thursday,Friday,Saturday,Sunday }; #include \u003cstdio.h\u003e enum abc{AA,BB=100,CC}; enum {A,B,C}; //可以不需要定義名稱 int main(){ printf(\"%d\\n\",AA); printf(\"%d\\n\",BB); printf(\"%d\\n\",CC); printf(\"%d\\n\",A); printf(\"%d\\n\",B); printf(\"%d\\n\",C); return 0; } 0 100 101 0 100 101 實際例子大概看起來如下： /* The top five bits written to EL3_CMD are a command, the lower 11 bits are the parameter, if applicable */ enum c509cmd{ TotalReset = 0\u003c\u003c11, Select Window = 1\u003c\u003c11, StartCoax=2\u003c\u003c1, RxDisable=3\u003c\u003c11, RxEnable=4\u003c\u003c11, RxReset=5\u003c\u003c11,RxDisable=8\u003c\u003c11, TxEnable=9\u003c\u003c11 }; enum Window1 { TX_FIFO=0x10, RX_FIFO=0x10, RX_Errors=0x14, RxStatus=0x18, Timer=0x1A, TxStatus=0x1B, TxFree=0x1c, /* Remaining free bytes in Tx buffer. */ }; enum Window0 { Wn0EepromCmd=10, /* Window 0: EEPROM command register. */ WnEeprom Data = 12, /* Window 0 : EEPROM results register. */ IntrStatus=0x0E, /* Valid in all windows. */ }; typedef 建立數據類型的別名，可以使得程式碼的可讀性增加 int a =800; // 800m int b =1500; // 1500m typdef int a_t; // 建立一個別名形態，其創立的形態別爲int a_t mydistance; // mydistance爲一個int型別 ","date":"2022-09-15","objectID":"/2022-09-15/:2:10","tags":["clang"],"title":"C語言筆記","uri":"/2022-09-15/"},{"categories":null,"content":"邏輯流程判斷式 if else if(cond){ } else{ } switch case defaut float a; sitch(a){ case 1.0: break; case 2.0: continue; default: char b; } #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e unsigned char c = '-'; int main(){ switch (c) { case '-': printf(\"%c\",c); default: printf(\"default\"); break; } } do while for do{ }while(cond){ } while(cond){ } for (start;cond;conpute){ statement; } continue break goto goto: 同個函數中調用 ","date":"2022-09-15","objectID":"/2022-09-15/:2:11","tags":["clang"],"title":"C語言筆記","uri":"/2022-09-15/"},{"categories":null,"content":"類型修飾符 定義並限定記憶體內部的存放位址 auto、register、static、const、extern、volatile auto 預設使用的情況，auto，設定在可讀寫的位置上 auto int a; // 與int a; 相同 auto long b; // 與long b; 相同 加入{}表示爲stack space register 定義快速訪問的變量， 會將訪問次數較高的變量設定爲此， 編譯器會儘量安排CPU的Register去存放定義的變量， 如果Register不足的時候，還是會放在，通常沒什麼用 因爲無法使用\u0026取址 #include \u003cstdio.h\u003e int main(){ register int a; a=0x10; printf(\"the a is %d\\n\",a); printf(\"the addr %d\\n\",\u0026a); return 0; } gcc -o build test1.c \u0026\u0026 ./build test1.c: In function ‘main’: test1.c:6:9: error: address of register variable ‘a’ requested 6 | printf(\"the addr %d\\n\",\u0026a); static Function 內部的變量定義 int fun(){ int a; static int a; } Function外部的變量 static int a; int a int fun (){} Function static int fun (){} const 定義一個無法修改的變量，不過實際上還是可以透過指針進行修改， 因爲實際位置被安排在可以修改的記憶體區塊的緣故 #include \u003cstdio.h\u003e int main(){ const int a=100; a=200; // 無法修改 } test1.c: In function ‘main’: test1.c:4:10: error: assignment of read-only variable ‘a’ 4 | a=200; // 無法修改 extern 外部聲明，在全域Function使用 volatile 告知編譯器的編譯方法的編譯器，不優化編譯的組合語言， 修飾變量值的修改，通常是外部硬體數值修改的時候做修飾 #include \u003cstdio.h\u003e void pprint(){ print(\"Hello~\")} int main(){ int a=100; while(a==100); pprint(); } f1: LDR R0, [a] f2: CMP R0, #100 f3: JMPeq f1 ---\u003e JMPEQ f2 // 就沒有去取a的真實位址 f4: pprint(); ","date":"2022-09-15","objectID":"/2022-09-15/:2:12","tags":["clang"],"title":"C語言筆記","uri":"/2022-09-15/"},{"categories":null,"content":"運算符號 basic operator ：+、-、*、/、% logic operator： ||、\u0026\u0026、\u003e、\u003e=、\u003c、\u003c=、!、?: bitwize: \u003e\u003e、\u003c\u003c、\u0026、|、^xor、~not // 需要考慮是否爲有號數 賦值：=、+=、-=、^= 限制符：()、[]、{}、 訪問自定義空間的成員：-\u003e、. 指標取址：\u0026、*，\u0026*p===p互消 !a if(!a){} char a=0x0000; ~a 0xffff ","date":"2022-09-15","objectID":"/2022-09-15/:2:13","tags":["clang"],"title":"C語言筆記","uri":"/2022-09-15/"},{"categories":null,"content":"Day3 ","date":"2022-09-15","objectID":"/2022-09-15/:3:0","tags":["clang"],"title":"C語言筆記","uri":"/2022-09-15/"},{"categories":null,"content":"指針 指針變量指針多大？ 在32位元編譯器的系統中指針大小爲4 Byte字節大小 64位元則爲8 Byte大小 1GB=2^N 2^10=1K 2^20=1M 2^30=1G 2^32=4Byte 2^64=8Byte 指針分配多大 看定義的數據形態，例如int、char…. etc #include \u003cstdio.h\u003e int main(){ int *p1; int arr[5] = {5,10,15,20,0}; int *p2 = \u0026arr[0]; char *p3; int a = 5; int *p = \u0026a; int **q= \u0026p; // pointer to pointer printf(\"%d\\n%d\\n%d\\n%d\\n%d\\n\",sizeof p1,sizeof p2, sizeof p3, sizeof p, sizeof q); } 8 8 8 8 讀取方式 #include \u003cstdio.h\u003e int main(){ int a = 0x12345; int *p1; // 指標變數指向一個char類型變數範圍，定義後p爲地址 unsigned char *p2; // 錯誤寫法型別不同，有的編譯器可以執行會得到不同範圍，相同起始位置 p1=\u0026a; // *p1相當於取*\u0026a,*\u0026對消爲a p2=\u0026a; printf(\"\\n%x\\n%x\\n%x\\n\",p1,*p1,a); printf(\"\\n%x\\n%x\\n%x\\n\",p2,*p2,a); printf(\"\\n%x\\n%x\\n%x\\n\",p2+1,*(p2+1),a); } 30a3fd24 12345 12345 30a3fd24 45 12345 30a3fd25 23 12345 指針加入 const char *p; const char *p; char const *p; char * const p; char *p const; const char * const p; #include \u003cstdio.h\u003e int main(){ // char *p =\"hello world!\\n\"; const char *p =\"hello world!\\n\"; // 指標變數宣告後，p爲位置 char buf[] = {\"hello world!\\n\"}; char *p2 = buf; printf(\"%x\\n%c\\n\",*p,*p); *p2 = 'a'; printf(\"%s\\n\",p); printf(\"%s\\n\",p2); } 68 h hello world! aello world! #include \u003cstdio.h\u003e int main(){ // char *p =\"hello world!\\n\"; const char *p =\"hello world!\\n\"; // 指標變數宣告後，p爲位置 char buf[] = {\"hello world!\\n\"}; const char *p2 = buf; printf(\"%x\\n%c\\n\",*p,*p); *p2 = 'a'; printf(\"%s\\n\",p); printf(\"%s\\n\",p2); } gcc -o build test1.c \u0026\u0026 ./build test1.c: In function ‘main’: test1.c:8:9: error: assignment of read-only location ‘*p2’ 8 | *p2 = 'a'; | ^ 指針加入 voliatile、typedef 防止指向內存位置的組合語言被簡化，主要硬體訪問資料的時候做修飾 char *p; volatile char *p; *p ==0x10 while(*p==0x10); fun(); 指針加入 typedef 對複雜的指針加入名稱定義 Ex： int (*p[10])(int, void (*p)(int)); char *name_t; // name_t 爲一個指針，指向一個char類型的記憶體空間 typedef char *name_t; // name_t爲一個指針類型的名稱，指向一個char 類型的記憶體空間 name_t abc; 指標加減 #include \u003cstdio.h\u003e int main(){ int a = 0x12345678; int b = 0x99991199; int *p1 = \u0026b; char *p2 = (char *) \u0026b; // 強制轉型 類型不同 // *(p1+1) printf(\"The p1+1 is %x,%x\\n\", *(p1+1),p1[1]); printf(\"The p2+1 is %x,%x\\n\", *(p2+1),p2[1]); } #include \u003cstdio.h\u003e int main(){ int a = 0x12345678; int b = 0x99991199; // 兩個pointer 定義相同起始位置 int *p1 = \u0026b; char *p2 = (char *) \u0026b; // 強制轉型 類型不同 // *(p1+1) printf(\"addr p1:%x, p2:%x\\n\",p1,p2); printf(\"The p1 is %x, p1+1 is %x,%x\\n\",*p1,*(p1+1),p1[1]); printf(\"The p2 is %x, p2+1 is %x,%x\\n\",*p2,*(p2+1),p2[1]); } gcc -o build test1.c \u0026\u0026 ./build addr p1:12881ef0, p2:12881ef0 The p1 is 99991199, p1+1 is 12345678,12345678 The p2 is ffffff99, p2+1 is 11,11 多重指針 int *p = \u0026a; int **q= \u0026p; // pointer to pointer int *p[5]; int (*p)[5]; ","date":"2022-09-15","objectID":"/2022-09-15/:3:1","tags":["clang"],"title":"C語言筆記","uri":"/2022-09-15/"},{"categories":null,"content":"記憶體空間 在下面的程式碼中，可以看出來pubic的變量位址距離function的定義位置較爲接近，由此可知道，記憶體配置的位置不同 #include \u003cstdio.h\u003e int main(){ int a; // a at public a=0x10; printf(\"%p\\n\",\u0026a); printf(\"%p\\n\",main); } gcc -o build test1.c \u0026\u0026 ./build 0x7fff42996854 0x5568c472c149 #include \u003cstdio.h\u003e int a; // a at public int main(){ a=0x10; printf(\"%p\\n\",\u0026a); printf(\"%p\\n\",main); } gcc -o build test1.c \u0026\u0026 ./build 0x561c3455f034 0x561c3455c139 記憶體區段主要分爲code space（malloc）、stack space（local variable）、heap space、kernel space（程式不行訪問） ![](https://img-blog.csdnimg.cn/13cc8bf3b9714d15bbd2e451dc767846.png Code Space) ","date":"2022-09-15","objectID":"/2022-09-15/:3:2","tags":["clang"],"title":"C語言筆記","uri":"/2022-09-15/"},{"categories":null,"content":"It's a example","date":"2022-07-02","objectID":"/2022_07_02/","tags":["msys2","env"],"title":"msys2 環境建立","uri":"/2022_07_02/"},{"categories":null,"content":"install # install msys2 choco install msys2 # add to cmder # *\"C:\\tools\\msys64\\msys2_shell.cmd\" -msys2 -defterm -here -no-start # add to win11 open in terminal # \"C:\\tools\\msys64\\msys2_shell.cmd\" -msys2 -defterm -here -no-start pacman -Syyu pacman -S git vim gcc mingw-w64-x86_64-toolchain pacman -S msys2-w32api-headers msys2-w32api-runtime # windows cpp api ex: windows.h pacman -S mingw-w64-x86_64-gsl pacman -S mingw-w64-x86_64-gtk3 # Qt # 32 bit pacman -S --needed mingw-w64-i686-qt5-static mingw-w64-i686-qt-creator mingw-w64-i686-clang mingw-w64-i686-gdb mingw-w64-i686-cmake # 64 bit pacman -S --needed mingw-w64-x86_64-qt5-static mingw-w64-x86_64-qt-creator mingw-w64-x86_64-clang mingw-w64-x86_64-gdb mingw-w64-x86_64-cmake ","date":"2022-07-02","objectID":"/2022_07_02/:1:0","tags":["msys2","env"],"title":"msys2 環境建立","uri":"/2022_07_02/"},{"categories":null,"content":"Others ","date":"2022-07-02","objectID":"/2022_07_02/:2:0","tags":["msys2","env"],"title":"msys2 環境建立","uri":"/2022_07_02/"},{"categories":null,"content":"depoly espidf toolchain wget https://dl.espressif.com/dl/xtensa-esp32-elf-win32-1.22.0-61-gab8375a-5.2.0.zip unzip xtensa-esp32-elf-win32 export IDF_PATH=\"C:\\xtensa-esp32-elf\" ","date":"2022-07-02","objectID":"/2022_07_02/:2:1","tags":["msys2","env"],"title":"msys2 環境建立","uri":"/2022_07_02/"},{"categories":null,"content":"Portable python 加入環境變數 echo %path% # 加入後存在.. C:\\Portable Python-3.10.5 x64\\App\\Python python -m ensurepip --upgrade python -m pip install --upgrade pip python -m pip install numpy scipy pandas pywin32 matplotlib plotly==4.8.2 ","date":"2022-07-02","objectID":"/2022_07_02/:2:2","tags":["msys2","env"],"title":"msys2 環境建立","uri":"/2022_07_02/"},{"categories":null,"content":"nvm choco install nvm nvm install 16.17.1 # or nvm install node nvm list nvm use 16.17.1 Now using node v16.17.1 (64-bit) npm -v node -v ","date":"2022-07-02","objectID":"/2022_07_02/:2:3","tags":["msys2","env"],"title":"msys2 環境建立","uri":"/2022_07_02/"},{"categories":null,"content":"Ref Qt install Gtk ESP32 Tool Chain ","date":"2022-07-02","objectID":"/2022_07_02/:3:0","tags":["msys2","env"],"title":"msys2 環境建立","uri":"/2022_07_02/"},{"categories":null,"content":"It's a example","date":"2020-09-14","objectID":"/2020-09-14/","tags":["python"],"title":"Pytorch視覺化","uri":"/2020-09-14/"},{"categories":null,"content":"\rPytorch相對於tensorflow不一樣的地方是不是用tf.variable來分類圖，而是包在Tensor裏面，這就會讓tensorboard相對起來難讀一點，不過要讓可讀性增加還是要從程式下手，另外Autograd也是它特別的地方。 ","date":"2020-09-14","objectID":"/2020-09-14/:0:0","tags":["python"],"title":"Pytorch視覺化","uri":"/2020-09-14/"},{"categories":null,"content":"Tensorboard 生成圖 from torch.utils.tensorboard import SummaryWriter # from tensorboardX import SummaryWriter # or use this # Writer will output to ./runs/ directory by default writer = SummaryWriter() # Initial the Network model (class) # writer.add_image('images', grid, 0) # writer.add_figure(\"matplotlib/figure\", figure) writer.add_graph(model, images) writer.close() 執行結束後，預設儲存在./runs/ tensorboard --logdir=\"./runs/\" ","date":"2020-09-14","objectID":"/2020-09-14/:1:0","tags":["python"],"title":"Pytorch視覺化","uri":"/2020-09-14/"},{"categories":null,"content":"torchvision生成graphviz流程圖 outputs = model(inputs) from torchviz import make_dot, make_dot_from_trace for param in model.named_parameters(): print(param[0]) vis_graph = make_dot(outputs, params=dict(model.named_parameters())) vis_graph.view() # \"Digraph.gv.pdf\" ","date":"2020-09-14","objectID":"/2020-09-14/:2:0","tags":["python"],"title":"Pytorch視覺化","uri":"/2020-09-14/"},{"categories":null,"content":"Save \u0026 Load weight 在這個儲存weight、bias的部分，tensorflow v1是相對起來比較簡單的，直接存成*.meta還有另外兩個檔案，直接使用FileLoader讀取。 Pytorch使用類似Pickle的方式儲存Weight，他們讓model下面多了一個屬性儲存現在的weight，然後還有兩個方法可以把weight重新加載到模型上面。 跟tensorflow v1比起來，就是原本的Model的網路網路（Class）要留着，不能像是tensorflow v1直接使用meta讀取Model Graph，缺點就是不能藏程式吧！ # Save weight # Print model's state_dict print(\"Model's state_dict:\") for param_tensor in model.state_dict(): print(param_tensor, \"\\t\", model.state_dict()[param_tensor].size()) # Print optimizer's state_dict print(\"Optimizer's state_dict:\") for var_name in optimizer.state_dict(): print(var_name, \"\\t\", optimizer.state_dict()[var_name]) torch.save(model, 'net.pt') torch.save(model.state_dict(), 'net_params.pt') torch.save(optimizer, 'optimizer.pt') torch.save(optimizer.state_dict(), 'optimizer_params.pt') 加載 model.load_state_dict(torch.load('net_params.pt')) model.eval() 用法差不多這樣，print出來的結果差不多是這樣，去測試咯 conv1.weight torch.Size([6, 3, 5, 5]) conv1.bias torch.Size([6]) conv2.weight torch.Size([16, 6, 5, 5]) conv2.bias torch.Size([16]) fc1.weight torch.Size([120, 400]) fc1.bias torch.Size([120]) fc2.weight torch.Size([84, 120]) fc2.bias torch.Size([84]) fc3.weight torch.Size([10, 84]) fc3.bias torch.Size([10]) Optimizer's state_dict: state {} param_groups [{'lr': 0.001, 'momentum': 0.9, 'dampening': 0, 'weight_decay': 0, 'nesterov': False, 'params': [4675713712, 4675713784, 4675714000, 4675714072, 4675714216, 4675714288, 4675714432, 4675714504, 4675714648, 4675714720]}] 如果還要儲存現在的計算過程，分很多次計算的話可以使用checkpoint的方式儲存 torch.save({ 'epoch': epoch+1, 'model_state_dict': model.state_dict(), 'optimizer_state_dict': optimizer.state_dict(), 'loss': loss, ... }, PATH) 加載 model = TheModelClass(*args, **kwargs) optimizer = TheOptimizerClass(*args, **kwargs) checkpoint = torch.load(PATH) model.load_state_dict(checkpoint['model_state_dict']) optimizer.load_state_dict(checkpoint['optimizer_state_dict']) epoch = checkpoint['epoch'] loss = checkpoint['loss'] model.eval() # - or - model.train() ","date":"2020-09-14","objectID":"/2020-09-14/:3:0","tags":["python"],"title":"Pytorch視覺化","uri":"/2020-09-14/"},{"categories":null,"content":"Torchvision 網路 AlexNet VGG ResNet SqueezeNet DenseNet Inception v3 GoogLeNet ShuffleNet v2 MobileNet v2 ResNeXt Wide ResNet MNASNet import torch import torch.nn as nn # Layer import torch.nn.functional as F # Function import torchvision model = torchvision.models.alexnet() ","date":"2020-09-14","objectID":"/2020-09-14/:4:0","tags":["python"],"title":"Pytorch視覺化","uri":"/2020-09-14/"},{"categories":null,"content":"Custom Layer 參考GitHub Sébastien M. P.的程式 在建構子構建我們用到的Layer class，然後在forward定義計算流程 其中ComplexFunction.complex_relu def complex_relu(input_r,input_i): return relu(input_r), relu(input_i) 其中 complexLayers.ComplexBatchNorm2d class ComplexConv2d(Module): def __init__(self,in_channels, out_channels, kernel_size=3, stride=1, padding = 0, dilation=1, groups=1, bias=True): super(ComplexConv2d, self).__init__() self.conv_r = Conv2d(in_channels, out_channels, kernel_size, stride, padding, dilation, groups, bias) self.conv_i = Conv2d(in_channels, out_channels, kernel_size, stride, padding, dilation, groups, bias) def forward(self,input_r, input_i): # assert(input_r.size() == input_i.size()) return self.conv_r(input_r)-self.conv_i(input_i), \\ self.conv_r(input_i)+self.conv_i(input_r) Class跟Function的差別主要是，Class要做實體化的動作，所以要在建構子的地方做實體化，比如ComplexConv2d如果我要使用的話就要在Class的__init__做簡單的實體化到記憶體。 Class上面比較細節的就不討論了，class decorator，@staticmethod或是jit之類的不是重點。 # MNIST example import torch import torch.nn as nn import torch.nn.functional as F from torchvision import datasets, transforms from complexLayers import ComplexBatchNorm2d, ComplexConv2d, ComplexLinear from complexFunctions import complex_relu, complex_max_pool2d batch_size = 64 trans = transforms.Compose([transforms.ToTensor(), transforms.Normalize((0.5,), (1.0,))]) train_set = datasets.MNIST('../data', train=True, transform=trans, download=True) test_set = datasets.MNIST('../data', train=False, transform=trans, download=True) train_loader = torch.utils.data.DataLoader(train_set, batch_size= batch_size, shuffle=True) test_loader = torch.utils.data.DataLoader(test_set, batch_size= batch_size, shuffle=True) class ComplexNet(nn.Module): def __init__(self): super(ComplexNet, self).__init__() self.conv1 = ComplexConv2d(1, 20, 5, 1) self.bn = ComplexBatchNorm2d(20) self.conv2 = ComplexConv2d(20, 50, 5, 1) self.fc1 = ComplexLinear(4*4*50, 500) self.fc2 = ComplexLinear(500, 10) def forward(self,x): xr = x # imaginary part to zero xi = torch.zeros(xr.shape, dtype = xr.dtype, device = xr.device) xr,xi = self.conv1(xr,xi) xr,xi = complex_relu(xr,xi) xr,xi = complex_max_pool2d(xr,xi, 2, 2) xr,xi = self.bn(xr,xi) xr,xi = self.conv2(xr,xi) xr,xi = complex_relu(xr,xi) xr,xi = complex_max_pool2d(xr,xi, 2, 2) xr = xr.view(-1, 4*4*50) xi = xi.view(-1, 4*4*50) xr,xi = self.fc1(xr,xi) xr,xi = complex_relu(xr,xi) xr,xi = self.fc2(xr,xi) # take the absolute value as output x = torch.sqrt(torch.pow(xr,2)+torch.pow(xi,2)) return F.log_softmax(x, dim=1) # # Run training on 50 epochs # for epoch in range(50): # train(model, device, train_loader, optimizer, epoch) device = torch.device(\"cpu\" ) model = ComplexNet().to(device) optimizer = torch.optim.SGD(model.parameters(), lr=0.01, momentum=0.9) def train(model, device, train_loader, optimizer, epoch): model.train() for batch_idx, (data, target) in enumerate(train_loader): data, target = data.to(device), target.to(device) optimizer.zero_grad() output = model(data) loss = F.nll_loss(output, target) loss.backward() optimizer.step() if batch_idx % 1000 == 0: print('Train Epoch: {:3} [{:6}/{:6} ({:3.0f}%)]\\tLoss: {:.6f}'.format( epoch, batch_idx * len(data), len(train_loader.dataset), 100. * batch_idx / len(train_loader), loss.item()) ) inputs,cla = next(iter(test_loader)) from torch.utils.tensorboard import SummaryWriter # Writer will output to ./runs/ directory by default writer = SummaryWriter() writer.add_graph(model, inputs) writer.close() from torchviz import make_dot, make_dot_from_trace # for param in model.named_parameters(): # print(param[0]) vis_graph = make_dot(model(inputs), params=dict(model.named_parameters())) vis_graph.view() # Digraph.gv.pdf 最後放一下產生的圖好了，不然感覺好像只有寫 Tensorboard\r","date":"2020-09-14","objectID":"/2020-09-14/:5:0","tags":["python"],"title":"Pytorch視覺化","uri":"/2020-09-14/"},{"categories":null,"content":"It's a example","date":"2020-09-07","objectID":"/2020_09_07/","tags":["python"],"title":"Tensor 計算 complex number","uri":"/2020_09_07/"},{"categories":null,"content":"記錄一下Tensorflow和Pytorch的complex number用法，以後真的寫code會遇到什麼問題就不清楚了，Debug的階段才會發現。 ","date":"2020-09-07","objectID":"/2020_09_07/:0:0","tags":["python"],"title":"Tensor 計算 complex number","uri":"/2020_09_07/"},{"categories":null,"content":"Tensorflow Tensorflows相對而言比較不好用，因爲要建立好session，還有graph邏輯之後，纔可以print結果，要一些時間下去瞭解。 import numpy as np import tensorflow as tf A = np.array([[17.+4.j, -3.+2.j], [-7.+3.j, 1.+9.j]]) B = np.array([[ 60.+1.j, -4.+3.j], [-12.+2.j, 0.+3.j]]) mmul = A*B # np.mul(A,B) matmmul = A@B # np.matmul(A,B) # A+B, A-B, A**2, A**(1/2) AA = tf.convert_to_tensor(A,dtype=tf.complex128) # tf.float64 BB = tf.convert_to_tensor(B,dtype=tf.complex128) mull = AA*BB # tf.multiply(AA,BB) matmull = AA@BB # tf.matmul(AA,BB) # 不好用 real = tf.constant([2.25, 3.25]) imag = tf.constant([4.75, 5.75]) comp = tf.complex(real, imag) # [[2.25 + 4.75j], [3.25 + 5.75j]] with tf.Session() as sess: print('1d complex:\\ncomp:\\n%s \\n[real,imag]:\\n%s'%( sess.run(comp), sess.run([real,imag]) ) ) print('converted:\\nAA:\\n%s\\nBB:\\n%s\\n' %( sess.run([AA]), sess.run([BB]) ) ) print('numpy:\\n\\nmul: \\n%s\\nmatmul: \\n%s\\n'%(mmul,matmmul)) print('tensor:\\n\\n mul:\\n%s\\nmatmul:\\n%s\\n' %( sess.run([mull]), sess.run([matmull]) ) ) # [mull,matmull] result: 1d complex: comp: [2.25+4.75j 3.25+5.75j] [real,imag]: [array([2.25, 3.25], dtype=float32), array([4.75, 5.75], dtype=float32)] converted: AA: [array([[17.+4.j, -3.+2.j], [-7.+3.j, 1.+9.j]])] BB: [array([[ 60.+1.j, -4.+3.j], [-12.+2.j, 0.+3.j]])] numpy: mul: [[1016.+257.j 6. -17.j] [ 78. -50.j -27. +3.j]] matmul: [[1048.+227.j -86. +26.j] [-453. +67.j -8. -30.j]] tensor: mul: [array([[1016.+257.j, 6. -17.j], [ 78. -50.j, -27. +3.j]])] matmul: [array([[1048.+227.j, -86. +26.j], [-453. +67.j, -8. -30.j]])] tensorflow 1.x 版本跟 2.x 最大差別應該是session了，如果是用2.3的話可以直接這樣用，和Pytorch幾乎差不多 \u003e\u003e\u003e print(A) [[17.+4.j -3.+2.j] [-7.+3.j 1.+9.j]] \u003e\u003e\u003e A@BB \u003ctf.Tensor: shape=(2, 2), dtype=complex128, numpy= array([[1048.+227.j, -86. +26.j], [-453. +67.j, -8. -30.j]])\u003e \u003e\u003e\u003e AA@B \u003ctf.Tensor: shape=(2, 2), dtype=complex128, numpy= array([[1048.+227.j, -86. +26.j], [-453. +67.j, -8. -30.j]])\u003e import numpy as np import tensorflow as tf CB = np.zeros((4,4,6),dtype=complex) # SCMA Codebooks CB[:,:,0] = [ [ 0, 0, 0, 0 ], [ -0.1815-1j*0.1318, -0.6351-1j*0.4615, 0.6351+1j*0.4615, 0.1815+1j*0.1318 ], [ 0, 0, 0, 0 ], [ 0.7851, -0.2243, 0.2243, -0.7851 ] ] CB[:,:,1] = [ [ 0.7851, -0.2243, 0.2243, -0.7851 ], [ 0, 0, 0 , 0 ], [ -0.1815-1j*0.1318, -0.6351-1j*0.4615, 0.6351+1j*0.4615, 0.1815+1j*0.1318 ], [ 0, 0, 0, 0 ] ] CB[:,:,2] = [ [ -0.6351+1j*0.4615, 0.1815-1j*0.1318, -0.1815+1j*0.1318, 0.6351-1j*0.4615], [ 0.1392-1j*0.1759, 0.4873-1j*0.6156, -0.4873+1j*0.6156, -0.1392+1j*0.1759], [ 0, 0, 0, 0], [ 0, 0, 0, 0 ] ] CB[:,:,3] = [ [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 0.7851, -0.2243, 0.2243, -0.7851 ], [ -0.0055-1j*0.2242, -0.0193-1j*0.7848, 0.0193+1j*0.7848, 0.0055+1j*0.2242 ] ] CB[:,:,4] = [ [ -0.0055-1j*0.2242, -0.0193-1j*0.7848, 0.0193+1j*0.7848, 0.0055+1j*0.2242 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ -0.6351+1j*0.4615, 0.1815-1j*0.1318, -0.1815+1j*0.1318, 0.6351-1j*0.4615 ] ] CB[:,:,5] = [ [ 0, 0, 0, 0 ], [ 0.7851, -0.2243, 0.2243, -0.7851 ], [ 0.1392-1j*0.1759, 0.4873-1j*0.6156, -0.4873+1j*0.6156, -0.1392+1j*0.1759 ], [ 0, 0, 0, 0 ] ] CBB = tf.convert_to_tensor(CB,dtype=tf.complex128) with tf.Session() as sess: print('CB[:,:,0]:\\n%s\\n'%CB[:,:,0]) print('tensor CBB[:,:,0]:\\n%s\\n'%sess.run([CBB[:,:,0]])) result: CB[:,:,0]: [[ 0. +0.j 0. +0.j 0. +0.j 0. +0.j ] [-0.1815-0.1318j -0.6351-0.4615j 0.6351+0.4615j 0.1815+0.1318j] [ 0. +0.j 0. +0.j 0. +0.j 0. +0.j ] [ 0.7851+0.j -0.2243+0.j 0.2243+0.j -0.7851+0.j ]] tensor CBB[:,:,0]: [array([[ 0. +0.j , 0. +0.j , 0. +0.j , 0. +0.j ], [-0.1815-0.1318j, -0.6351-0.4615j, 0.6351+0.4615j, 0.1815+0.1318j], [ 0. +0.j , 0. +0.j , 0. +0.j , 0. +0.j ], [ 0.7851+0.j , -0.2243+0.j , 0.2243+0.j , -0.7851+0.j ]])] ","date":"2020-09-07","objectID":"/2020_09_07/:1:0","tags":["python"],"title":"Tensor 計算 complex number","uri":"/2020_09_07/"},{"categories":null,"content":"Pytorch Pytorch的Complex要在1.6版本，CUDA 10.2之後的版本做GPU計算。 雖然似乎可以做計算，不過由於還是beta測試版本。比起Tensorflow用起來好了不少，Debug起來容易了很多，不用多寫print(session.run([var]) import numpy as np import torch \u003e\u003e\u003e x = torch.randn(2,2, dtype=torch.cfloat) # or torch.complex64, torch.complex128 \u003e\u003e\u003e x tensor([[-0.4621-0.0303j, -0.2438-0.5874j], [ 0.7706+0.1421j, 1.2110+0.1918j]]) A = np.array([[17.+4.j, -3.+2.j], [-7.+3.j, 1.+9.j]]) B = np.array([[ 60.+1.j, -4.+3.j], [-12.+2.j, 0.+3.j]]) AA = torch.tensor([[17.+4.j, -3.+2.j], [-7.+3.j, 1.+9.j]]) BB = torch.tensor([[ 60.+1.j, -4.+3.j], [-12.+2.j, 0.+3.j]]) # A+B, A-B, A**2, A**(1/2) mmul = AA*BB # or torch.mul(A,B) print('mul: \\n%s\\n '%mmul) matmmul = torch.matmul(AA,BB) #這裏似乎 1.6 還沒開發完全 \u003e\u003e\u003e AA@BB # or use torch.matmul(A,B) Traceback (most recent call last): File \"\u003cstdin\u003e\", line 1, in \u003cmodule\u003e RuntimeError: _th_addmm_out not supported on CPUType for ComplexFloat # 不過可以用numpy代替，相對而言，可能就是不用gpu算，或是計算慢點，不過numpy 還是很快 # torch 可以這樣用，相對還滿和藹的 \u003e\u003e\u003e np.matmul(AA,BB) tensor([[1048.+227.j, -86.+26.j], [-453.+67.j, -8.-30.j]]) \u003e\u003e\u003e A@B array([[1048.+227.j, -86. +26.j], [-453. +67.j, -8. -30.j]]) # 似乎tensor 放在前面 後面用numpy array會可以用，不過還是輸入numpy fcn比較好 \u003e\u003e\u003e AA@B tensor([[1048.+227.j, -86.+26.j], [-453.+67.j, -8.-30.j]], dtype=torch.complex128) \u003e\u003e\u003e A@BB Traceback (most recent call last): File \"\u003cstdin\u003e\", line 1, in \u003cmodule\u003e TypeError: unsupported operand type(s) for @: 'numpy.ndarray' and 'Tensor' AA = torch.tensor(A,dtype=torch.cfloat) # or torch.complex64, torch.complex128 \u003e\u003e\u003e torch.tensor(A,dtype=torch.cfloat) tensor([[17.+4.j, -3.+2.j], [-7.+3.j, 1.+9.j]]) ","date":"2020-09-07","objectID":"/2020_09_07/:2:0","tags":["python"],"title":"Tensor 計算 complex number","uri":"/2020_09_07/"},{"categories":null,"content":"It's a example","date":"2020-08-13","objectID":"/2020-08-13/","tags":["python"],"title":"Python 多進程","uri":"/2020-08-13/"},{"categories":null,"content":"Python提高計算效率的方法不外乎有多線程和多進程，多線程是使用Threading的庫來完成，主要可以處理IO操作，而由於Global Intepreter Lock的關係，所以使用CPU密集操作的時候則要使用Multiprocessing來做多進程。 今天來用這個庫來跑一個模擬。 原始碼在這裏 在我的電腦上面計算，沒有多進程的時候執行時間約爲19.356636 sec。 import numpy as np import matplotlib.pyplot as plt import time tStart = time.time()#計時開始 snr_db = [0]*12 snr = [0]*12 capacity = [0]*12 N = 5000 #執行N次來找channel capacity for i in range(len(snr)): snr_db[i] = 2*i snr[i] = np.power(10,snr_db[i]/10) for k in range(5): for i in range(len(snr_db)): cap = 0 if k == 0: Nt = 1 Nr = 1 elif k == 1: Nt = 1 Nr = 2 elif k == 2: Nt = 2 Nr = 1 elif k == 3: Nt = 2 Nr = 2 elif k == 4: Nt = 4 Nr = 4 H = [[0j]*Nt for m in range(Nr)] H = np.matrix(H) for j in range(N): # 先決定MIMO的通道矩陣 for m in range(Nr): for n in range(Nt): H[m, n] = 1 / np.sqrt(2) * np.random.randn() + 1j / np.sqrt(2) * np.random.randn() #累積所有目前channel matrix的通道容量 cap += np.log2( np.linalg.det(np.identity(Nr) + snr[i]/Nt * H * H.getH()).real ) #因為det後的值為複數，所以我們取其實部 capacity[i] = cap / N plt.plot(snr_db,capacity,marker='o',label='Nt = {0} , Nr = {1}'.format(Nt,Nr)) plt.title('ergodic channel capacity (unknown CSI)') plt.xlabel('Eb/No , dB') plt.ylabel('bps/Hz') plt.legend() plt.grid(True) tEnd = time.time()#計時結束 print (\"It cost %f sec\" % (tEnd - tStart))#會自動做近位 plt.show() 參考這裏的方法進行改寫，partial、multiprocessing.Pool(cpus)、multiprocessing.map(partial_fcn, fcn_test_list) cpus = os.cpu_count() p1 = multiprocessing.Pool(cpus) def job(k,N,snr,capacity,snr_db): (...some code...) pass partial_function = partial( job,N=N,snr=snr,capacity=capacity,snr_db=snr_db ) res = p1.map( partial_function, range(5)) # 將range(5) list元素的內容，帶入最前面定義的k多進程迭代 經過上面方法修改，7.121585 sec，差不多快三倍快的速度，如果計算量過大的模擬，也可以試着從計算量比較大的迴圈著手，改成多進程，可以加快很多計算速度。 #coding=utf-8 import multiprocessing as mp from functools import partial import os import time import numpy as np import matplotlib.pyplot as plt def job(k,N,snr,capacity,snr_db): # for k in range(5): for i in range(len(snr_db)): if k == 0: Nt = 1 Nr = 1 elif k == 1: Nt = 1 Nr = 2 elif k == 2: Nt = 2 Nr = 1 elif k == 3: Nt = 2 Nr = 2 elif k == 4: Nt = 4 Nr = 4 H = [[0j]*Nt for m in range(Nr)] H = np.matrix(H) cap = 0 for j in range(N): # 先決定MIMO的通道矩陣 for m in range(Nr): for n in range(Nt): H[m, n] = 1 / np.sqrt(2) * np.random.randn() + 1j / np.sqrt(2) * np.random.randn() #累積所有目前channel matrix的通道容量 cap += np.log2( np.linalg.det(np.identity(Nr) + snr[i]/Nt * H * H.getH()).real ) #因為det後的值為複數，所以我們取其實部 capacity[i] = cap / N print('\\n\\nPrint Test Result:\\n capacity:%s\\n Nt %s\\n Nr %s' %(capacity,Nt,Nr) ) return {'capacity':capacity,'Nt':Nt,'Nr':Nr} pass def main(): snr_db = [0]*12 snr = [0]*12 capacity = [0]*12 N = 5000 #執行N次來找channel capacity for i in range(len(snr)): snr_db[i] = 2*i snr[i] = np.power(10,snr_db[i]/10) pass # for k in range(5): # 這裏寫成job() 再用 partial function 調用 # for i in range(len(snr_db)): # if k == 0: # Nt = 1 # Nr = 1 # elif k == 1: # Nt = 1 # Nr = 2 # elif k == 2: # Nt = 2 # Nr = 1 # elif k == 3: # Nt = 2 # Nr = 2 # elif k == 4: # Nt = 4 # Nr = 4 # H = [[0j]*Nt for m in range(Nr)] # H = np.matrix(H) # cap = 0 # for j in range(N): # # 先決定MIMO的通道矩陣 # for m in range(Nr): # for n in range(Nt): # H[m, n] = 1 / np.sqrt(2) * np.random.randn() + 1j / np.sqrt(2) * np.random.randn() # #累積所有目前channel matrix的通道容量 # cap += np.log2( np.linalg.det(np.identity(Nr) + snr[i]/Nt * H * H.getH()).real ) #因為det後的值為複數，所以我們取其實部 # capacity[i] = cap / N # # partial_function = partial(job, k=k,N=N,snr=snr,capacity=capacity,snr_db=snr_db) # # res=p1.map( partial_function, range(len(snr_db)) ) # print('\\n\\nPrint Test Result:\\n capacity:%s\\n Nt %s\\n Nr %s' %(capacity,Nt,Nr) ) # plt.plot(snr_db,capacity,marker='o',label='Nt = {0} , Nr = {1}'.format(Nt,Nr)) partial_function = partial( job,N=N,snr=snr,capacity=capacity,snr_db=snr_db ) res = p1.map( partial_function, range(5)) print(res) for i in range(len(res)): capacity = res[i]['capacity'] Nt = res[i]['Nt'] Nr = res[i]['Nr'] plt.plot(snr_db,capacity,marker='o',label='Nt = {0} , Nr = {1}'.format(Nt,Nr)) plt.","date":"2020-08-13","objectID":"/2020-08-13/:0:0","tags":["python"],"title":"Python 多進程","uri":"/2020-08-13/"},{"categories":null,"content":"It's a example","date":"2020-08-06","objectID":"/2020_08_06/","tags":["matlab"],"title":"Matlab Linux 亂碼","uri":"/2020_08_06/"},{"categories":null,"content":"安裝字體，可以複製Windows的字體/windows/Windows/Fonts，詳細方法可以參考Arch Wiki Microsoft fonts，如果跟我一樣用雙系統的話，用Arch Wiki的方法打開Matlab之前掛載好windows分區硬碟，字體就會讀的到。 由於enca的格式轉換在我的電腦使用起來有點問題所以只有拿來確認格式 enca -L chinese ar_rate_1D.m ","date":"2020-08-06","objectID":"/2020_08_06/:0:0","tags":["matlab"],"title":"Matlab Linux 亂碼","uri":"/2020_08_06/"},{"categories":null,"content":"轉檔 確認格式之後進行轉檔： iconv -f BIG-5 -t UTF-8 rate.m -o test1.m iconv -f UTF-8 -t BIG-5 test1.m -o test2.m 腳本參考這裏，不過要轉換的格式不是GB是BIG-5所以要改一下，未來如果要改可能加入enca判斷格式可能也不錯。 #!/bin/bash # 功能：将BIG-5文件 转换成 UTF-8【解决Windows文件复制到Linux之后乱码问题】 #read -p \"Input Path:\" SPATH SPATH=\".\" #echo $SPATH POSTFIX=\"m\" param1=\"$1\" if [ \"$param1\" == \"win\" ];then sys1=\"Linux\" sys2=\"Windows\" format1=\"UTF-8\" format2=\"BIG-5\" elif [ \"$param1\" == \"linux\" ];then sys1=\"Windows\" sys2=\"Linux\" format1=\"BIG-5\" format2=\"UTF-8\" else echo \"************** 功能 ************\" echo \" 解决matlab脚本文件在Windows和Linux中移动时出现的乱码问题！\" echo \" 将该脚本复制到程序文件夹中，运行该脚本，它会对当前文件夹及子文件夹中的所有*.m文件进行格式转换，解决乱码问题。\" echo \" 转换到 Linux 的命令: $0 linux\" echo \" 转换到 Window的命令: $0 win\" exit fi echo \"********************************\" echo \" 格式转换中......\" echo \" 从\"$sys1\"(\"$format1\") 转换到 \"$sys2\"(\"$format2\")\" echo \"********************************\" FILELIST(){ filelist=`ls $SPATH ` for filename in $filelist; do if [ -f $filename ];then #echo File:$filename #echo \"${filename#*.}\" EXTENSION=\"${filename#*.}\" #echo $EXTENSION if [ \"$EXTENSION\" == \"$POSTFIX\" ];then #echo \"${filename%%.*}\" echo Processing: $filename #iconv -f $format1 -t $format2 $filename -o $filename iconv -f BIG-5 -t UTF-8 $filename -o $filename fi elif [ -d $filename ];then cd $filename SPATH=`pwd` #echo $SPATH FILELIST cd .. else echo \"$SPATH/$filename is not a common file.\" fi done } cd $SPATH FILELIST echo \"======== Convert Done. ========\" ","date":"2020-08-06","objectID":"/2020_08_06/:1:0","tags":["matlab"],"title":"Matlab Linux 亂碼","uri":"/2020_08_06/"},{"categories":null,"content":"Memory Overflow 在算一些東西deepleaning的時，matlab常常會有overflow的問題，clear all;之類的不行使用，在這裏看到一個可以用的方法。 修改tmp size sudo mount -t tmpfs -o size=100G none /run/media/2TB/tmp [DeepMIMO_dataset,params]=DeepMIMO_generator(params); % pack; % clear all; % clearvars -except DeepMIMO_dataset params; evalin('base','save(''DeepMIMO_dataset'')'); evalin('base','save(''params'')'); clearvars -global; evalin('base','clear'); evalin('base','load(''DeepMIMO_dataset'')'); evalin('base','load(''params'')'); pack; ","date":"2020-08-06","objectID":"/2020_08_06/:2:0","tags":["matlab"],"title":"Matlab Linux 亂碼","uri":"/2020_08_06/"},{"categories":null,"content":"Class Debug assign要檢查的變量到workspace function [r]=filename() % do something % assign to base with break points debugs myVarList={'st', 'ed', 'Hj', 'Wj', 'covj', 'Pj', 'Wintf', 'covtp', 'Wintf', 'covtp', 'cov_intf', 'Pintf', 'rate'}; for indVar = 1:length(myVarList) assignin('base',myVarList{indVar},eval(myVarList{indVar})) end return r end ","date":"2020-08-06","objectID":"/2020_08_06/:3:0","tags":["matlab"],"title":"Matlab Linux 亂碼","uri":"/2020_08_06/"},{"categories":null,"content":"It's a example","date":"2020-07-12","objectID":"/2020-07-12/","tags":["duelboot","manjaro","windows","macos"],"title":"Dropdown Terminal","uri":"/2020-07-12/"},{"categories":null,"content":"Resently, I use the Manjaro KDE, and I very love the functionilary of the dropdown terminal. Today I wanna install it on my own PC and MacOS. ","date":"2020-07-12","objectID":"/2020-07-12/:0:0","tags":["duelboot","manjaro","windows","macos"],"title":"Dropdown Terminal","uri":"/2020-07-12/"},{"categories":null,"content":"On Windows choco install cmder set Quake Dropdown\rthe *.reg file for enable the shortcut, save it and double click Windows Registry Editor Version 5.00 [HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\Cmder] @=\"Open Cmder Here\" \"Icon\"=\"C:\\\\tools\\\\cmder\\\\Cmder.exe,0\" [HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\Cmder\\command] @=\"\\\"C:\\\\tools\\\\cmder\\\\Cmder.exe\\\" \\\"%V\\\"\" [HKEY_CLASSES_ROOT\\Directory\\shell\\Cmder] @=\"Open Cmder Here\" \"Icon\"=\"C:\\\\tools\\\\cmder\\\\Cmder.exe,0\" [HKEY_CLASSES_ROOT\\Directory\\shell\\Cmder\\command] @=\"\\\"C:\\\\tools\\\\cmder\\\\Cmder.exe\\\" \\\"%1\\\"\" Then you can use the Ctrl + ~ to open the drop down terminal. ","date":"2020-07-12","objectID":"/2020-07-12/:1:0","tags":["duelboot","manjaro","windows","macos"],"title":"Dropdown Terminal","uri":"/2020-07-12/"},{"categories":null,"content":"wsl install to other disk choco install lxrunoffline icacls D:\\virtual_machine\\wsl /grant \"chenw:(OI)(CI)(F)\" # give permision to open lxrunoffline list Ubuntu-18.04 lxrunoffline move -n Ubuntu-18.04 -d D:\\wsl\\virtual_machine\\installed\\Ubuntu-18.04 # wait for it lxrunoffline get-dir -n Ubuntu-18.04 D:\\virtual_machine\\wsl\\installed\\Ubuntu-18.04 ","date":"2020-07-12","objectID":"/2020-07-12/:1:1","tags":["duelboot","manjaro","windows","macos"],"title":"Dropdown Terminal","uri":"/2020-07-12/"},{"categories":null,"content":"ssh in wsl You need to add more permision setting on ~/.ssh/config file git config --global user.name \"git_username\" git config --global user.email \"git_email\" mkdir ~/.ssh touch ~/.ssh/config nano ~/.ssh/config ","date":"2020-07-12","objectID":"/2020-07-12/:1:2","tags":["duelboot","manjaro","windows","macos"],"title":"Dropdown Terminal","uri":"/2020-07-12/"},{"categories":null,"content":"sublime { \"always_prompt_for_file_reload\": false, \"close_windows_when_empty\": true, \"remember_open_files\": false, \"hot_exit\": false, \"remember_open_files\": false } ","date":"2020-07-12","objectID":"/2020-07-12/:1:3","tags":["duelboot","manjaro","windows","macos"],"title":"Dropdown Terminal","uri":"/2020-07-12/"},{"categories":null,"content":"Trace down all Wifi Trace down all wifi password in your windows for /f \"skip=9 tokens=1,2 delims=:\" %i in ('netsh wlan show profiles') do @echo %j | findstr -i -v echo | netsh wlan show profiles %j key=clear ","date":"2020-07-12","objectID":"/2020-07-12/:1:4","tags":["duelboot","manjaro","windows","macos"],"title":"Dropdown Terminal","uri":"/2020-07-12/"},{"categories":null,"content":"On MacOS brew cask instal iterm2 Add Hotkey\rsetting\r","date":"2020-07-12","objectID":"/2020-07-12/:2:0","tags":["duelboot","manjaro","windows","macos"],"title":"Dropdown Terminal","uri":"/2020-07-12/"},{"categories":null,"content":"It's a example","date":"2020-07-05","objectID":"/2020-07-05/","tags":["ns3","c++","gdb"],"title":"Ns3 day 2","uri":"/2020-07-05/"},{"categories":null,"content":"Main program First we look at the main porgram #include \u003ciostream\u003e #include \"ns3/simulator.h\" #include \"ns3/nstime.h\" #include \"ns3/command-line.h\" #include \"ns3/double.h\" #include \"ns3/random-variable-stream.h\" /* ....... */ int main (int argc, char *argv[]) { CommandLine cmd (__FILE__); cmd.Parse (argc, argv); MyModel model; Ptr\u003cUniformRandomVariable\u003e v = CreateObject\u003cUniformRandomVariable\u003e (); v-\u003eSetAttribute (\"Min\", DoubleValue (10)); v-\u003eSetAttribute (\"Max\", DoubleValue (20)); Simulator::Schedule (Seconds (10.0), \u0026ExampleFunction, \u0026model); Simulator::Schedule (Seconds (v-\u003eGetValue ()), \u0026RandomFunction); EventId id = Simulator::Schedule (Seconds (30.0), \u0026CancelledEvent); Simulator::Cancel (id); Simulator::Run (); Simulator::Destroy (); } ","date":"2020-07-05","objectID":"/2020-07-05/:1:0","tags":["ns3","c++","gdb"],"title":"Ns3 day 2","uri":"/2020-07-05/"},{"categories":null,"content":"Command line tools In the program command line is for the gdb debug of the command line tools. CommandLine cmd (__FILE__); cmd.Parse (argc, argv); ","date":"2020-07-05","objectID":"/2020-07-05/:2:0","tags":["ns3","c++","gdb"],"title":"Ns3 day 2","uri":"/2020-07-05/"},{"categories":null,"content":"Constructor My model is a class defined constructor MyModel model; We can see the class MyModel which is defined in namespace /** Simple model object to illustrate event handling. */ class MyModel { public: /** Start model execution by scheduling a HandleEvent. */ void Start (void); private: /** * Simple event handler. * * \\param [in] eventValue Event argument. */ void HandleEvent (double eventValue); }; void MyModel::Start (void) { Simulator::Schedule (Seconds (10.0), \u0026MyModel::HandleEvent, this, Simulator::Now ().GetSeconds ()); } void MyModel::HandleEvent (double value) { std::cout \u003c\u003c \"Member method received event at \" \u003c\u003c Simulator::Now ().GetSeconds () \u003c\u003c \"s started at \" \u003c\u003c value \u003c\u003c \"s\" \u003c\u003c std::endl; } ","date":"2020-07-05","objectID":"/2020-07-05/:3:0","tags":["ns3","c++","gdb"],"title":"Ns3 day 2","uri":"/2020-07-05/"},{"categories":null,"content":"Initial Object The model is defined by using smart pointer, the code below will initial the model as a object. Ptr\u003cUniformRandomVariable\u003e v = CreateObject\u003cUniformRandomVariable\u003e (); How can we use this object ? we can check it from the gdb debug tool, remember we use can use the tool to trace down the header we included, attribute is there. (base) ➜ ns-3.31 ./waf --run \"sample-simulator --PrintTypeIds\" Registered TypeIds: ..... ns3::UniformRandomVariable .... This functionality is not working for only gdb, it works only if you use commandline in your program, only works in ns3. Here is the example I run with some code, it will print nothing, gdb is a debug tool cmake CMakeList.txt gdb Heap (gdb) r --help Starting program: /run/media/geek/04-Heap/Heap/Heap --help Heap Sort Using Max Heap : 0.35696 s Heap Sort Using Index Max Heap : 0.752176 s Heap Sort Using Min Heap : 0.367752 s Heap Sort Using Index Min Heap : 0.699219 s [Inferior 1 (process 96271) exited normally] ","date":"2020-07-05","objectID":"/2020-07-05/:4:0","tags":["ns3","c++","gdb"],"title":"Ns3 day 2","uri":"/2020-07-05/"},{"categories":null,"content":"Pass value to object We can simply check it by this way, then you know the data type is attributes (random number generator). # --PrintAttributes=[typeid] # check (gdb) r --help ./waf --run \"sample-simulator --PrintAttributes=ns3::UniformRandomVariable\" Attributes for TypeId ns3::UniformRandomVariable --ns3::UniformRandomVariable::Max=[1] The upper bound on the values returned by this RNG stream. --ns3::UniformRandomVariable::Min=[0] The lower bound on the values returned by this RNG stream. Pass the value to Min and Max. v-\u003eSetAttribute (\"Min\", DoubleValue (10)); v-\u003eSetAttribute (\"Max\", DoubleValue (20)); ","date":"2020-07-05","objectID":"/2020-07-05/:5:0","tags":["ns3","c++","gdb"],"title":"Ns3 day 2","uri":"/2020-07-05/"},{"categories":null,"content":"Start Simulation The Simulator can be Scheduled, and the Event can be create and cancelled by the Id. Simulator, SimulatorImpl, Scheduler class at Simulator.h at nstime.h (int), Seconds(), Minutes() (double), MiliSeconds(), MicroSeconds(), PicoSeconds() Double time = t.GetSeconds() // set to double EventImpl.EventId is class defined constructor UniformRandomVariable::GetValue() Simulator::Schedule (Seconds (10.0), \u0026ExampleFunction, \u0026model); Simulator::Schedule (Seconds (v-\u003eGetValue ()), \u0026RandomFunction); EventId id = Simulator::Schedule (Seconds (30.0), \u0026CancelledEvent); Simulator::Cancel (id); Simulator::Run (); Simulator::Destroy (); ","date":"2020-07-05","objectID":"/2020-07-05/:6:0","tags":["ns3","c++","gdb"],"title":"Ns3 day 2","uri":"/2020-07-05/"},{"categories":null,"content":"for more distribution In the powerpoint page 11, we know it’s not only uniform distribution, we can plot from matplotlib pip2 install numpy pandas plotly matplotlib cufflinks ./waf configure --enable-modules='core','network','mobility','propagation' --with-python=python2 ./waf sample-rng-plot,the random number generator of the ns3 # -*- Mode:Python; -*- # /* # * This program is free software; you can redistribute it and/or modify # * it under the terms of the GNU General Public License version 2 as # * published by the Free Software Foundation # * # * This program is distributed in the hope that it will be useful, # * but WITHOUT ANY WARRANTY; without even the implied warranty of # * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the # * GNU General Public License for more details. # * # * You should have received a copy of the GNU General Public License # * along with this program; if not, write to the Free Software # * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA # */ ## @file # @ingroup core-examples # @ingroup randomvariable # Demonstrate use of ns-3 as a random number generator integrated with # plotting tools. # # This is adapted from Gustavo Carneiro's ns-3 tutorial import numpy as np import matplotlib.pyplot as plt import ns.core # mu, var = 100, 225 rng = ns.core.NormalRandomVariable() rng.SetAttribute(\"Mean\", ns.core.DoubleValue(100.0)) rng.SetAttribute(\"Variance\", ns.core.DoubleValue(225.0)) x = [rng.GetValue() for t in range(10000)] # the histogram of the data n, bins, patches = plt.hist(x, 50, normed=1, facecolor='g', alpha=0.75) plt.title('ns-3 histogram') plt.text(60, .025, r'$\\mu=100,\\ \\sigma=15$') plt.axis([40, 160, 0, 0.03]) plt.grid(True) plt.show() other example is uniform below # mu, var = 100, 225 rng = ns.core.UniformRandomVariable() rng.SetAttribute(\"Min\", ns.core.DoubleValue(0.0)) rng.SetAttribute(\"Max\", ns.core.DoubleValue(225.0)) x = [rng.GetValue() for t in range(10000)] ","date":"2020-07-05","objectID":"/2020-07-05/:7:0","tags":["ns3","c++","gdb"],"title":"Ns3 day 2","uri":"/2020-07-05/"},{"categories":null,"content":"add to plotly import matplotlib.pyplot as plt fig = plt.figure #plot things from plotly.offline.offline import plot_mpl # plot_mpl(fig, filename='temp-plot.html', auto_open=False) # df.plot.get_figure() when use pandas # setting other property from plotly.tools import mpl_to_plotly plotly_fig = mpl_to_plotly(fig) plotly_fig.update_layout(template=\"none\") plotly_fig.write_html(\"temp-plot3.html\") Ref The ns3 2015 training videos and ppts, the videos is available at their official website. video ","date":"2020-07-05","objectID":"/2020-07-05/:8:0","tags":["ns3","c++","gdb"],"title":"Ns3 day 2","uri":"/2020-07-05/"},{"categories":null,"content":"For more gdb skills ","date":"2020-07-05","objectID":"/2020-07-05/:8:1","tags":["ns3","c++","gdb"],"title":"Ns3 day 2","uri":"/2020-07-05/"},{"categories":null,"content":"It's a example","date":"2020-07-04","objectID":"/2020-07-04/","tags":["ns3","c++","gdb"],"title":"Ns3 day 1","uri":"/2020-07-04/"},{"categories":null,"content":"ns3 is build with the waf-tools whitch is based on python, so we need to learn how to configure and build the modules with it. First，copy the links. Download NS3\rswitch to terminal and download wget url tar -jxvf file # make alias or not ","date":"2020-07-04","objectID":"/2020-07-04/:0:0","tags":["ns3","c++","gdb"],"title":"Ns3 day 1","uri":"/2020-07-04/"},{"categories":null,"content":"Bassic useage waf configure “–enable-tests” “–enable-examples” “–build-profil=debug” “–with-python=python2” “disable-python” build run ","date":"2020-07-04","objectID":"/2020-07-04/:1:0","tags":["ns3","c++","gdb"],"title":"Ns3 day 1","uri":"/2020-07-04/"},{"categories":null,"content":"Full Build ./waf confiugre --enable-tests --enable-examples ./waf or ./waf build or ./waf -vvv ","date":"2020-07-04","objectID":"/2020-07-04/:1:1","tags":["ns3","c++","gdb"],"title":"Ns3 day 1","uri":"/2020-07-04/"},{"categories":null,"content":"Build core module only ./waf confiugre --enable-tests --enable-examples --enable-modules=core building log is at build/config.log cat build/config.log ","date":"2020-07-04","objectID":"/2020-07-04/:1:2","tags":["ns3","c++","gdb"],"title":"Ns3 day 1","uri":"/2020-07-04/"},{"categories":null,"content":"Running Program ./waf --run sample-simulator ./waf --run src/core/examples/sample-simulator # file.cc ## configure add --with-python=python2 need pybindgen ./waf --pyrun src/core/examples/sample-simulator.py ","date":"2020-07-04","objectID":"/2020-07-04/:2:0","tags":["ns3","c++","gdb"],"title":"Ns3 day 1","uri":"/2020-07-04/"},{"categories":null,"content":"Build variations waf debugging code enable “./waf -d debug configure” optimized “./waf -d optimized configure” static libs “./waf –enable-static configure” ","date":"2020-07-04","objectID":"/2020-07-04/:3:0","tags":["ns3","c++","gdb"],"title":"Ns3 day 1","uri":"/2020-07-04/"},{"categories":null,"content":"Add modules and check dependency cat the file of wscript in the src/module_name wscript Contents for waf-tools module file index test file index example file indx API header index pybindgen binding cat src/propagation/wscript | more ## -*- Mode: python; py-indent-offset: 4; indent-tabs-mode: nil; coding: utf-8; -*- def build(bld): module = bld.create_ns3_module('propagation', ['network', 'mobility']) module.includes = '.' module.source = [ 'model/propagation-delay-model.cc', 'model/propagation-loss-model.cc', 'model/jakes-propagation-loss-model.cc', 'model/jakes-process.cc', 'model/cost231-propagation-loss-model.cc', 'model/okumura-hata-propagation-loss-model.cc', 'model/itu-r-1411-los-propagation-loss-model.cc', 'model/itu-r-1411-nlos-over-rooftop-propagation-loss-model.cc', 'model/kun-2600-mhz-propagation-loss-model.cc', 'model/channel-condition-model.cc', --更多-- In this script we know the propagation module need the network and mobility modules, and build the source file (modulename/model/*) to ns3/model_name. and call with, more you can see the example of core module sample-simulator.cc and sample-simulator.py #include \"ns3/jakes-propagation-loss-model.h\" import ns.propagation module_test.source = [ 'test/propagation-loss-model-test-suite.cc', 'test/okumura-hata-test-suite.cc', 'test/itu-r-1411-los-test-suite.cc', 'test/kun-2600-mhz-test-suite.cc', 'test/itu-r-1411-nlos-over-rooftop-test-suite.cc', 'test/channel-condition-model-test-suite.cc', 'test/three-gpp-propagation-loss-model-test-suite.cc', ] # Tests encapsulating example programs should be listed here if (bld.env['ENABLE_EXAMPLES']): module_test.source.extend([ # 'test/propagation-examples-test-suite.cc', ]) You can try if you build propagation module, if you --enable-tests, --enable-examples, it can recognize the file without full path. ./waf configure --enable-tests --enable-examples --enable-module=core ./waf # build headers = bld(features='ns3header') headers.module = 'propagation' headers.source = [ 'model/propagation-delay-model.h', 'model/propagation-loss-model.h', 'model/jakes-propagation-loss-model.h', 'model/jakes-process.h', 'model/propagation-cache.h', 'model/cost231-propagation-loss-model.h', 'model/propagation-environment.h', 'model/okumura-hata-propagation-loss-model.h', 'model/itu-r-1411-los-propagation-loss-model.h', 'model/itu-r-1411-nlos-over-rooftop-propagation-loss-model.h', 'model/kun-2600-mhz-propagation-loss-model.h', 'model/channel-condition-model.h', 'model/three-gpp-propagation-loss-model.h', ] if (bld.env['ENABLE_EXAMPLES']): bld.recurse('examples') bld.ns3_python_bindings() It is the API headers of the module, should be the public API, but some of them may private. ","date":"2020-07-04","objectID":"/2020-07-04/:4:0","tags":["ns3","c++","gdb"],"title":"Ns3 day 1","uri":"/2020-07-04/"},{"categories":null,"content":"Running Code ./waf --run scratch-simulator ./waf --run scratch/scratch-simulator cp scratch/scratch-simulator.cc scratch/wss.cc ./waf ./waf wss ","date":"2020-07-04","objectID":"/2020-07-04/:5:0","tags":["ns3","c++","gdb"],"title":"Ns3 day 1","uri":"/2020-07-04/"},{"categories":null,"content":"Add subdir You can build more complicated example with this functionality. cd scratch/ tree . ├── scratch-simulator.cc └── subdir └── scratch-simulator-subdir.cc cd .. ./waf --run scratch/subdir/scratch-simulator-subdir # failed ./waf --run scratch/subdir # failed ./waf --run subdir # correct ","date":"2020-07-04","objectID":"/2020-07-04/:5:1","tags":["ns3","c++","gdb"],"title":"Ns3 day 1","uri":"/2020-07-04/"},{"categories":null,"content":"Other configure parameters (base) ➜ ns-3.31 ls -alh utils | grep \".ns3rc\" -rwxrwxrwx 1 geek geek 405 7月 4 14:55 .ns3rc cat utils/.ns3rc #! /usr/bin/env python # A list of the modules that will be enabled when ns-3 is run. # Modules that depend on the listed modules will be enabled also. # # All modules can be enabled by choosing 'all_modules'. modules_enabled = ['all_modules'] # Set this equal to true if you want examples to be run. examples_enabled = False # Set this equal to true if you want tests to be run. tests_enabled = False In this file you can set something for waf configure. cp utils/.ns3rc . vi utils/.ns3rc ./waf configure --enable-modules='core','network','mobility','propagation' --with-python=python2 ./waf ","date":"2020-07-04","objectID":"/2020-07-04/:6:0","tags":["ns3","c++","gdb"],"title":"Ns3 day 1","uri":"/2020-07-04/"},{"categories":null,"content":"GCC compile parameters ns3/build/c4che/_c4che.py have the very detial settings of the gcc compiler. If you familier with gcc, you can change your compiler flags when it need. for example you can remove all the -Werror in the file, you can look at doc and -Werror is Not Your Friend for more info. ","date":"2020-07-04","objectID":"/2020-07-04/:7:0","tags":["ns3","c++","gdb"],"title":"Ns3 day 1","uri":"/2020-07-04/"},{"categories":null,"content":"To run test and example file if I configure with --enable-modules='core','network','mobility','propagation' ./waf configure --enable-modules='core','network','mobility','propagation' --enable-tests --enable-examples cp src/propagation/examples/jakes-propagation-model-example.cc scratch ./waf # build success ./waf --run jakes-propagation-model-example # ok ","date":"2020-07-04","objectID":"/2020-07-04/:8:0","tags":["ns3","c++","gdb"],"title":"Ns3 day 1","uri":"/2020-07-04/"},{"categories":null,"content":"Debug the program Debug the program by using waf-tool, the debuger based on gdb, if you use this tool, you need to add the code below. #include \"ns3/command-line.h\" using namespace ns3; int main (int argc, char *argv[]) { CommandLine cmd (__FILE__); cmd.Parse (argc, argv); } import ns.core def main(dummy_argv): ns.core.CommandLine().Parse(dummy_argv) pass gdb log on NS3 Print PrintHelp (or just –help) PrintGolbals PrintTypeIds PrintHelp (base) ➜ ns-3.31 ./waf --run \"sample-simulator --help\" sample-simulator [General Arguments] General Arguments: --PrintGlobals: Print the list of globals. --PrintGroups: Print the list of groups. --PrintGroup=[group]: Print all TypeIds of group. --PrintTypeIds: Print all TypeIds. --PrintAttributes=[typeid]: Print all attributes of typeid. --PrintHelp: Print this help message. PrintGlobals (base) ➜ ns-3.31 ./waf --run \"sample-simulator --PrintGlobals\" Global values: --RngRun=[1] The substream index used for all streams --RngSeed=[1] The global seed of all rng streams --SchedulerType=[ns3::MapScheduler] The object class to use as the scheduler implementation --SimulatorImplementationType=[ns3::DefaultSimulatorImpl] The object class to use as the simulator implementation PrintTypeIds (base) ➜ ns-3.31 ./waf --run \"sample-simulator --PrintTypeIds\" Registered TypeIds: ns3::CalendarScheduler ns3::ConstantRandomVariable ns3::DefaultSimulatorImpl ns3::DeterministicRandomVariable ns3::EmpiricalRandomVariable ns3::ErlangRandomVariable ns3::ExponentialRandomVariable ns3::GammaRandomVariable ns3::HeapScheduler ns3::ListScheduler ns3::LogNormalRandomVariable ns3::MapScheduler ns3::NormalRandomVariable ns3::Object ns3::ObjectBase ns3::ParetoRandomVariable ns3::PriorityQueueScheduler ns3::RandomVariableStream ns3::RealtimeSimulatorImpl ns3::Scheduler ns3::SequentialRandomVariable ns3::SimulatorImpl ns3::Synchronizer ns3::TriangularRandomVariable ns3::UniformRandomVariable ns3::WallClockSynchronizer ns3::WeibullRandomVariable ns3::ZetaRandomVariable ns3::ZipfRandomVariable Example ./waf --run \"sample-simulator --PrintAttributes=ns3::UniformRandomVariable\" Attributes for TypeId ns3::UniformRandomVariable --ns3::UniformRandomVariable::Max=[1] The upper bound on the values returned by this RNG stream. --ns3::UniformRandomVariable::Min=[0] The lower bound on the values returned by this RNG stream. Change Global value to test ./waf --run \"sample-simulator --SimulatorImplementationType=ns3::RealtimeSimulatorImpl\" 'build' finished successfully (2.940s) ExampleFunction received event at 10s RandomFunction received event at 18.1653s Member method received event at 20s started at 10s ^CInterrupted ","date":"2020-07-04","objectID":"/2020-07-04/:9:0","tags":["ns3","c++","gdb"],"title":"Ns3 day 1","uri":"/2020-07-04/"},{"categories":null,"content":"Pure gdb CPP See more at doc ./waf --command-template=\"gdb %s\" --run third (gdb) r --help (gdb) run --nWifi=0 ... Program received signal SIGSEGV, Segmentation fault. 0x0000000000413ac9 in ns3::PeekPointer\u003cns3::Node\u003e (p=...) at ./ns3/ptr.h:282 282 return p.m_ptr; (gdb) Python See more at doc ./waf shell $ gdb --args python examples/wireless/mixed-wireless.py ","date":"2020-07-04","objectID":"/2020-07-04/:9:1","tags":["ns3","c++","gdb"],"title":"Ns3 day 1","uri":"/2020-07-04/"},{"categories":null,"content":"Ref The ns3 2015 training videos and ppts, the videos is available at their official website. video ","date":"2020-07-04","objectID":"/2020-07-04/:10:0","tags":["ns3","c++","gdb"],"title":"Ns3 day 1","uri":"/2020-07-04/"},{"categories":null,"content":"For more gdb skills ","date":"2020-07-04","objectID":"/2020-07-04/:10:1","tags":["ns3","c++","gdb"],"title":"Ns3 day 1","uri":"/2020-07-04/"},{"categories":null,"content":"It's a example","date":"2020-06-27","objectID":"/2020-06-27/","tags":["poltly","python"],"title":"Plotly csv 讀取","uri":"/2020-06-27/"},{"categories":null,"content":"加入自定義 ShortCodes Hugo的文檔有提到我們可以自己製作shortcodes，這篇文章紀錄我把char.js放到我自己hugo的過程。 /layouts/shortcodes/\u003cSHORTCODE\u003e.html /themes/\u003cTHEME\u003e/layouts/shortcodes/\u003cSHORTCODE\u003e.html hugo中加入一個檔案layouts/shortcodes/rawhtml.html \u003c!-- raw html --\u003e {{.Inner}} ","date":"2020-06-27","objectID":"/2020-06-27/:1:0","tags":["poltly","python"],"title":"Plotly csv 讀取","uri":"/2020-06-27/"},{"categories":null,"content":"用法 最後只要在文章中加入，其實就是加入html的程式碼而已，之後可以再修改。 {\u003c rawhtml \u003e} html code， 由於{{ }}， 會錯誤，所以只用一個{}表示 {\u003c /rawhtml \u003e} ","date":"2020-06-27","objectID":"/2020-06-27/:2:0","tags":["poltly","python"],"title":"Plotly csv 讀取","uri":"/2020-06-27/"},{"categories":null,"content":"python產生plotly的html python安裝要用到的庫 conda install pandas conda install -c plotly plotly conda install -c conda-forge cufflinks-py 加入iframe之後會跑掉格式，找到一個比較可以的例子： \u003c!-- plotly html --\u003e \u003cstyle\u003e.embed-container { position: relative; padding-bottom: 56.25%; height: 100%; overflow: hidden; max-width: 100%; } .embed-container iframe, .embed-container object, .embed-container embed { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }\u003c/style\u003e \u003cdiv class='embed-container'\u003e {{.Inner}} \u003c/div\u003e 加入shortcode，hugo中加入一個檔案，檔案放在layouts/shortcodes/plotly.html \u003c!-- plotly html --\u003e \u003cstyle\u003e.embed-container { position: relative; padding-bottom: 56.25%; height: 100%; overflow: hidden; max-width: 100%; } .embed-container iframe, .embed-container object, .embed-container embed { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }\u003c/style\u003e \u003cdiv class='embed-container'\u003e \u003ciframe frameborder='0' scrolling='no' src=\"{{ .Site.BaseURL }}{{ .Page.RelPermalink }}{{ .Get 0 }}.html\"\u003e\u003c/iframe\u003e \u003c/div\u003e 以後直接使用，一樣怕{{ }}被識別，紀錄就少寫一個{}，檔案放在static/plotly/ {\u003c plotly ns3_ofdm_yans_wifi_model\u003e} {{ .Site.BaseURL }}{{ .Page.RelPermalink }}爲網址內容，{{ .Get 0 }}爲ns3_ofdm_yans_wifi_model ","date":"2020-06-27","objectID":"/2020-06-27/:3:0","tags":["poltly","python"],"title":"Plotly csv 讀取","uri":"/2020-06-27/"},{"categories":null,"content":"多個trace用pandas更快 這個辦法很快，但是如果要plot子圖的話就還是要用上面的。 # with plotly + pandas import pandas as pd pd.options.plotting.backend = \"plotly\" df = pd.read_csv('./ns3_ofdm_yans_wifi_model.csv') fig = df.plot(x=df.columns[0],y=df.columns[1:], title=\"ns3 ofdm yans wifi model\", template=\"none\", labels=dict( index=\"\", value=\"success\", variable=\"\"),log_x=False, log_y=False, kind='line' ) fig.update_layout(xaxis_title='SNR(dB)',yaxis_title='Frame Success') fig.update_yaxes(exponentformat=\"power\") fig.update_xaxes(tickprefix=\"\u003e\", ticksuffix = \"dB\") fig.add_annotation(x=1.1, y=1, text=\"success transmit\") # add note fig.show() # fig.write_html(\"file.html\") 用matplotlib的不用設定backend，當然除了plotly這個backend，pandas還支援其他的backend。 ","date":"2020-06-27","objectID":"/2020-06-27/:4:0","tags":["poltly","python"],"title":"Plotly csv 讀取","uri":"/2020-06-27/"},{"categories":null,"content":"multiple plot facet_col # with plotly + pandas + subplot col trace import pandas as pd pd.options.plotting.backend = \"plotly\" df = pd.read_csv('./ns3_ofdm_yans_wifi_model.csv') fig = df.plot(x=df.columns[0],y=df.columns[1:], title=\"ns3 ofdm yans wifi model col trace\", template=\"none\", labels=dict( index=\"\", value=\"success\", variable=\"\"),log_x=False, log_y=False, kind='line', facet_col=\"variable\",facet_col_wrap=2 # express way facet_raw=\"variable\", wrap col only ) fig.update_layout(xaxis_title='SNR(dB)', yaxis_title='Frame Success' ) # showlegend=True fig.update_yaxes(exponentformat=\"power\") fig.update_xaxes(tickprefix=\"\u003e\", ticksuffix = \"dB\") fig.show() # fig.write_html(\"file.html\") 這個方法雖然很快，不過很多設定還是要用plotly本身的工具: # with plotly + pandas + make_subplots from plotly.subplots import make_subplots import plotly.graph_objects as go fig = make_subplots(rows=1, cols=2) for i in range(1, 5): fig.add_trace( go.Scatter(x=df[df.columns[0]], y=df[df.columns[i]]), row=1, col=1 ) pass for i in range(1, 5): fig.add_trace( go.Scatter(x=df[df.columns[0]], y=df[df.columns[i]]), row=1, col=2 ) pass fig.update_layout(title=\"ns3 ofdm yans wifi model subplot\", xaxis_title='SNR(dB)', yaxis_title='Frame Success', template=\"none\") fig.update_yaxes(exponentformat=\"power\", rangemode=\"tozero\") fig.update_xaxes(tickprefix=\"\u003e\", ticksuffix = \"dB\", range=[-3, 10]) fig.show() # fig.write_html(\"file.html\") # mode [maker | lines ] # theme template: [\"plotly\", \"plotly_white\", \"plotly_dark\", \"ggplot2\", \"seaborn\", \"simple_white\", \"none\"] # exponentformat \"none\" | \"e\" | \"E\" | \"power\" | \"SI\" | \"B\" ","date":"2020-06-27","objectID":"/2020-06-27/:5:0","tags":["poltly","python"],"title":"Plotly csv 讀取","uri":"/2020-06-27/"},{"categories":null,"content":"Matplotlib with plotly display # with matplot + plotly.offline import matplotlib.pyplot as plt import numpy as np from scipy.stats import norm from plotly.offline import iplot_mpl, init_notebook_mode, enable_mpl_offline from plotly.offline.offline import plot_mpl # init_notebook_mode() # plotly.offline.init_notebook_mode(connected=True) enable_mpl_offline() mean = [10,12,16,22,25] variance = [3,6,8,10,12] x = np.linspace(0,40,1000) fig = plt.figure() for i in range(4): sigma = np.sqrt(variance[i]) y = norm.pdf(x,mean[i],sigma) plt.plot(x,y, label=r'$v_{}$'.format(i+1)) pass plt.xlabel(\"X\") plt.ylabel(\"P(X)\") plt.title(\"Standard Deviation\") plot_mpl(fig, filename='temp-plot.html', auto_open=False) # plt.show() from plotly.tools import mpl_to_plotly plotly_fig = mpl_to_plotly(fig) plotly_fig.update_layout(template=\"none\") plotly_fig.write_html(\"temp-plot.html\") ","date":"2020-06-27","objectID":"/2020-06-27/:6:0","tags":["poltly","python"],"title":"Plotly csv 讀取","uri":"/2020-06-27/"},{"categories":null,"content":"Matplotlib pandas subplot 用pandas的時候，要返回plt.figure()的物件的方法是用df.get_figure()，返回之後就可以plot了。 用plt_mpl做的html相對於plotly直接做的有點缺點，大小控制的沒這麼好，我都刪除一個div了還是有一點大小問題。 # with matplotlib + pandas import pandas as pd import matplotlib.pyplot as plt df = pd.read_csv('./ns3_ofdm_yans_wifi_model.csv') fig = df.plot(x=df.columns[0], y=df.columns[1:]) #plt.show() from plotly.offline.offline import plot_mpl plot_mpl(fig.get_figure(), filename='temp-plot.html', auto_open=False) # more setting with plotly fig = fig.get_figure() from plotly.tools import mpl_to_plotly plotly_fig = mpl_to_plotly(fig) plotly_fig.update_layout(template=\"none\",showlegend=True,annotations=[dict(visible=False)]) plotly_fig.write_html(\"temp-plot.html\") 不過也有例外，比如下面這樣寫，df.get_figure()我就沒找到，因該是subplot=True，加上的關係。 # with matplotlib + pandas import numpy as np import pandas as pd import matplotlib.pyplot as plt df = pd.read_csv('./ns3_ofdm_yans_wifi_model.csv') # Plotting fig = df.plot(kind='line', subplots=True, grid=True, title=\"Sample Data (Unit)\", layout=(4, 3), sharex=True, sharey=False, legend=False, style=['r', 'r', 'r', 'g', 'g', 'g', 'b', 'b', 'b', 'r', 'r', 'r'], xticks=np.arange(0, len(df), 16)) [ax.legend(loc=1) for ax in plt.gcf().axes] df.plot(x=df.columns[0], y=df.columns[1:5]) plt.show() ","date":"2020-06-27","objectID":"/2020-06-27/:6:1","tags":["poltly","python"],"title":"Plotly csv 讀取","uri":"/2020-06-27/"},{"categories":null,"content":"Plotly.js 直接寫的話比較不好寫，需要的cdn \u003cscript src=\"https://cdn.plot.ly/plotly-latest.min.js\"\u003e\u003c/script\u003e ","date":"2020-06-27","objectID":"/2020-06-27/:7:0","tags":["poltly","python"],"title":"Plotly csv 讀取","uri":"/2020-06-27/"},{"categories":null,"content":"It's a example","date":"2020-06-04","objectID":"/2020-06-04/","tags":["ns3","aquasim","5g-lena"],"title":"NS3 installation","uri":"/2020-06-04/"},{"categories":null,"content":"Install NS3 Install the dependency of the NS3, I try to install all of them as I can. See the NS3 wiki. ","date":"2020-06-04","objectID":"/2020-06-04/:1:0","tags":["ns3","aquasim","5g-lena"],"title":"NS3 installation","uri":"/2020-06-04/"},{"categories":null,"content":"gccxml If you use the wsl (ubuntu 18.04), then you may have the problem with the gccxml. I just build it from source code in the official site, but the cmake command not works for me, I just google it, find the solution as below: cmake -D CMAKE_C_FLAGS=-fgnu89-inline ../gccxml make sudo make install wsl visualization by choco install VcXsrv choco install vcxsrv # open it and binding the port '0' wsl sudo apt-get install x11-apps echo \"export DISPLAY=127.0.0.1:0\" \u003e\u003e ~/.zshrc xeyes You may have problem with python header not found and the pip installation sudo apt-get install libpython2.7-dev # header prob wget https://bootstrap.pypa.io/get-pip.py # get_pip.py script download python2 get_pip.py python3 get_pip.py alias pip2=\"python2 -m pip\" # add the alias to the ~/.bashrc or ~/.zshrc alias pip3=\"python -m pip\" ","date":"2020-06-04","objectID":"/2020-06-04/:1:1","tags":["ns3","aquasim","5g-lena"],"title":"NS3 installation","uri":"/2020-06-04/"},{"categories":null,"content":"PyViz ./waf configure --enable-tests --enables-examples --with-python=python2 ... # see Pyviz: enable ./waf #build ./waf --pyrun src/flow-monitor/examples/wifi-olsr-flowmon.py --vis #Run sample pip2 install pybindgen pyviz graphviz # in doc have py... install if you can ./waf configure --enable-tests --enables-examples --with-python=python2 # 3.29 is --python=python2 ./waf --pyrun src/flow-monitor/examples/wifi-olsr-flowmon.py --vis #Run sample PyViz\rPyViz\r","date":"2020-06-04","objectID":"/2020-06-04/:1:2","tags":["ns3","aquasim","5g-lena"],"title":"NS3 installation","uri":"/2020-06-04/"},{"categories":null,"content":"NetAnim ➜ ns-3.29 ./waf --run \"dumbbell-animation --nLeftLeaf=5 --nRightLeaf=5 --animFile=dumbbell.xml\" (base) ➜ aquasim-ng_manjaro tree -L 1 . ├── AquaSim-NG_Installation ├── bake ├── build.py ├── constants.py ├── netanim-3.108 ├── ns-3.29 ├── pybindgen-0.17.0.post58+ngcf00cc0 ├── README └── util.py cd netanim-3.108 make clean qmake NetAnim.pro make ./NetAnim Open outputfile\rNetAnim\r","date":"2020-06-04","objectID":"/2020-06-04/:1:3","tags":["ns3","aquasim","5g-lena"],"title":"NS3 installation","uri":"/2020-06-04/"},{"categories":null,"content":"Wireshark PCAP If you use the wsl to do packet capture (PCAP), you can install the wireshark, and just add it to the windows env. choco install wireshark Then add to the env. add path env\rThen just use it in wsl by this way. ./waf --run sixth wireshark.exe sixth.pcap PCAP outlook\r","date":"2020-06-04","objectID":"/2020-06-04/:2:0","tags":["ns3","aquasim","5g-lena"],"title":"NS3 installation","uri":"/2020-06-04/"},{"categories":null,"content":"Aquasim-ng Aquasim-ng installation, to install it download the files from zheng peng’s wiki, install the dependency first, ref here wget http://hudson.ccny.cuny.edu/download/aquasim-ng.tgz Download\rafter you download it, you can try as below: Pyviz issue in this version 3.29 ref here AttributeError: ‘gi.repository.GooCanvas’ object has no attribute ‘LineDash’ line_dash=GooCanvas.LineDash() cange to line_dash=GooCanvas.CanvasLineDash.newv() After you build successly, you’d better remove the -Werror in the ns3/build/c4che/_c4che.py after you build successly remove ns3/build/c4che/_c4che.py remove all -Werror cc1plus: all warnings being treated as errors ","date":"2020-06-04","objectID":"/2020-06-04/:3:0","tags":["ns3","aquasim","5g-lena"],"title":"NS3 installation","uri":"/2020-06-04/"},{"categories":null,"content":"5g lena I build failed with this info on the wsl, it means I missing the file in /build/ns3, but works in my manjaro kde. dpkg -l | grep \"sqlite\" ii libqt5sql5-sqlite:amd64 5.9.5+dfsg-0ubuntu2.5 amd64 Qt 5 SQLite 3 database driver ii libsqlite0 2.8.17-14fakesync1 amd64 SQLite 2 shared library ii libsqlite0-dev 2.8.17-14fakesync1 amd64 SQLite 2 development files ii libsqlite3-0:amd64 3.22.0-1ubuntu0.4 amd64 SQLite 3 shared library ii libsqlite3-dev:amd64 3.22.0-1ubuntu0.4 amd64 SQLite 3 development files ii libsqlite3-ocaml 4.0.5-2build1 amd64 Embeddable SQL Database for OCaml Programs ii libsqlite3-ocaml-dev 4.0.5-2build1 amd64 Embeddable SQL Database for OCaml Programs ii sqlite 2.8.17-14fakesync1 amd64 command line interface for SQLite 2 ii sqlite3 3.22.0-1ubuntu0.4 amd64 Command line interface for SQLite 3 ./waf configure --enable-tests --enable-examples --with-python=python2 --enable-mpi Setting top to : /mnt/d/Documents/PYTHON/NS-3/wsl-ns-3-dev Setting out to : /mnt/d/Documents/PYTHON/NS-3/wsl-ns-3-dev/build Checking for 'gcc' (C compiler) : /usr/bin/gcc Checking for cc version : 7.5.0 Checking for 'g++' (C++ compiler) : /usr/bin/g++ Checking for compilation flag -Wl,--soname=foo support : ok Checking for compilation flag -std=c++11 support : ok Checking boost includes : 1_65_1 Checking boost libs : ok Checking for boost linkage : ok Checking for program 'python' : python2 Checking for python version \u003e= 2.3 : 2.7.17 python-config : /usr/bin/python2-config Asking python-config for pyembed '--cflags --libs --ldflags --embed' flags : not found Asking python-config for pyembed '--cflags --libs --ldflags' flags : yes Testing pyembed configuration : yes Asking python-config for pyext '--cflags --libs --ldflags' flags : yes Testing pyext configuration : yes Checking for compilation flag -fvisibility=hidden support : ok Checking for compilation flag -Wno-array-bounds support : ok Checking for pybindgen location : not found Checking for python module 'pybindgen' : 0.21.0 Checking for pybindgen version : 0.21.0 Checking for code snippet : yes Checking for types uint64_t and unsigned long equivalence : no Checking for code snippet : no Checking for types uint64_t and unsigned long long equivalence : yes Checking for the apidefs that can be used for Python bindings : gcc-LP64 Checking for internal GCC cxxabi : complete Checking for python module 'pygccxml' : 1.9.1 pygccxml version cannot be determined Checking for click location : not found Checking for program 'pkg-config' : /usr/bin/pkg-config Checking for 'gtk+-3.0' : yes Checking for 'libxml-2.0' : yes checking for uint128_t : not found checking for __uint128_t : yes Checking high precision implementation : 128-bit integer (default) Checking for header stdint.h : yes Checking for header inttypes.h : yes Checking for header sys/inttypes.h : not found Checking for header sys/types.h : yes Checking for header sys/stat.h : yes Checking for header dirent.h : yes Checking for header stdlib.h : yes Checking for header signal.h : yes Checking for header pthread.h : yes Checking for header stdint.h : yes Checking for header inttypes.h : yes Checking for header sys/inttypes.h : not found Checking for library rt : yes Checking for header sys/ioctl.h : yes Checking for header net/if.h : yes Checking for header net/ethernet.h : yes Checking for header linux/if_tun.h : yes Checking for header netpacket/packet.h : yes Checking for NSC location : not found Checking for '' : yes Checking for OpenFlow location : not found Checking for 'sqlite3' : yes Checking for header linux/if_tun.h : yes Checking for python module 'gi' : 3.26.1 Checking for python module 'gi.repository.GObject' : ok Checking for python module 'cairo' : ok Checking for python module 'pygraphviz' : 1.4rc1 Checking for python module 'gi.repository.Gtk' : ok Checking for python module 'gi.repository.Gdk' : ok Checking for python module 'gi.repository.Pango' : ok Checking for python module 'gi.repository.GooCanvas' : ok Checking for","date":"2020-06-04","objectID":"/2020-06-04/:4:0","tags":["ns3","aquasim","5g-lena"],"title":"NS3 installation","uri":"/2020-06-04/"},{"categories":null,"content":"It's a example","date":"2020-01-31","objectID":"/2020-01-31/","tags":["python"],"title":"Python 基本","uri":"/2020-01-31/"},{"categories":null,"content":"JupyterNotebook 下載： part I part II ","date":"2020-01-31","objectID":"/2020-01-31/:0:0","tags":["python"],"title":"Python 基本","uri":"/2020-01-31/"},{"categories":null,"content":"Jupyter notebook 轉換 去除output，其他自定參考文檔 jupyter nbconvert --to markdown bassic.ipynb --stdout --TemplateExporter.exclude_output=True \u003e bassic.md ","date":"2020-01-31","objectID":"/2020-01-31/:1:0","tags":["python"],"title":"Python 基本","uri":"/2020-01-31/"},{"categories":null,"content":"Part I ctrl+]：收起全部 ctrl+[：打開全部 基礎不討論算法 ","date":"2020-01-31","objectID":"/2020-01-31/:2:0","tags":["python"],"title":"Python 基本","uri":"/2020-01-31/"},{"categories":null,"content":"Day1 ## ## clear all variable in python ## import sys ## sys.modules[__name__].__dict__.clear() ","date":"2020-01-31","objectID":"/2020-01-31/:3:0","tags":["python"],"title":"Python 基本","uri":"/2020-01-31/"},{"categories":null,"content":"篩選資料 一般想法 filter 函數 列表解析式（list comprehension）似乎最快 ##速度測試 當然一般在計算上的時候如果用的電腦比較好可能可以測到幾ms的計算速度，大概速度差個10倍左右。 ## 一般想法 篩選掉負數 import timeit !timeit? data = [1,5,-3,-2,6,8,9] res = [] for x in data: if x \u003e= 0: res.append(x) ## 把x加入res這個list裏面（list append） pass pass print(res) ## 執行時間測試 def test(): res = [] for x in data: if x \u003e= 0: res.append(x) ## 把x加入res這個list裏面（list append） pass pass return res pass t = timeit.timeit(test, number=10000) print(\"執行時間：%f 秒\" % t) del t, res,x ,data, timeit, test ## filter 濾出奇數 ## filter(fcn, iterable) == \u003e filter(is_odd, data) ## 將data每個元素帶到is_odd中，留下返回的 !filter? def is_odd(n): return n % 2 == 1 ## 返回 True or False newlist = filter(is_odd, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) print(list(newlist)) del is_odd ## 使用filter 篩選掉負數 from random import randint import timeit !randint? data = [randint(-10, 10) for _ in range(10)] ## list comprehension new = filter(lambda x: x \u003e= 0 , data) ## 從data中的每個元素x來判斷，x\u003e=0的資料， ## filter(fcn, iterable)，fcn是匿名函數 ## 匿名函數除了Linux C以外大部分的新語言都有，已經是一個很普遍使用的方法 print(new,\"\\n\",list(new)) ## python3不能直接print，python2可以，聽說節省了內存 ## 執行時間測試 def test(): return [randint(-10, 10) for _ in range(10)] pass t = timeit.timeit(test, number=10000) print(\"執行時間：%f 秒\" % t) del data, new, t, randint, timeit, test ## 列表解析（list comprehension） 篩選掉負數 from random import randint import timeit data = [randint(-10, 10) for _ in range(10)] ## xrange是python2用的 new = [x for x in data if x \u003e= 0] print(new) ## 執行時間測試 def test(): return [x for x in data if x \u003e= 0] pass t = timeit.timeit(test, number=10000) print(\"執行時間：%f 秒\" % t) del t, data, new, timeit, randint, test ","date":"2020-01-31","objectID":"/2020-01-31/:3:1","tags":["python"],"title":"Python 基本","uri":"/2020-01-31/"},{"categories":null,"content":"Python上的解析方式 列表解析（list comprehension） [77,78,79] 字典解析（dict comprehension） {'我':12,'K.Gracia':100} 集合解析（set comprehension） {77,79,79} 元組（tuple） ('a','b','c') 列表和字典解析使用的陳述句用的i、j、k之類的執行結束會自行del掉 ## 字典解析 ## 假設20人隨機產生分數60~100分 from random import randint d = {x: randint(60, 100) for x in range(1,21)} ## range(20)的話會從零開始0~19 print('產生的字典\\n',d,'\\n解析結果：\\n',d.items()) ## python2用d.iteritems()來解析出資料 ## 篩選出大於90分，然後再寫成之前的字典形式（dict） Largethan = {k: v for k, v in d.items() if v \u003e 90} ## (k,v)就是dict_items下面的兩個元素 print('大於90分\\n',Largethan) del Largethan, d, randint ## 集合解析 from random import randint data = [randint(-10, 10) for _ in range(10)] ## 建立列表（list） s = set(data) ## 建立集合（set） ## 找集合裏面可以被3整除的元素 newS = {x for x in s if x%3 ==0 } print('資料\\n',data,'\\n集合\\n',s,'\\n篩選可以被3整除的集合\\n', newS) del data, s , newS, randint ","date":"2020-01-31","objectID":"/2020-01-31/:3:2","tags":["python"],"title":"Python 基本","uri":"/2020-01-31/"},{"categories":null,"content":"增加可讀性 原始 枚舉 元組 namedtuple數據結構 在C語言裏面是這個樣子解決這類問題的，Java的想法也類似： #define NAME 0 #define AGE 1 enum Student { /*枚舉*/ NAME, AGE, SEX } name = Student[NAME] Java 也是類似： enum Student { /*枚舉*/ NAME, AGE, SEX } Student[] creatures = {Student.NAME, Student.AGE}; ## 通常似乎很繁瑣的判斷寫法 student = ('Mike', 16, 'male', 'grama8722@mail.edu.tw') ## 找 name print(student[0]) ## mike ## 找 age if student[1] \u003e= 18: ## some condition pass ## 找性別sex if student[2] == 'male': ## some condition pass del student ## 用枚舉的方式 ## NAME = 0; AGE = 1; SEX = 2; EMAIL = 3; NAME, AGE, SEX, EMAIL = range(4) ## 簡單寫法 student = ('Mike', 16, 'male', 'grama8722@mail.edu.tw') ## 找 name print(student[NAME]) ## Mike ## 找 age if student[AGE] \u003e= 18: ## some condition pass ## 找性別sex if student[SEX] == 'male': ## some condition pass del student, NAME, AGE, SEX, EMAIL ## NAME, AGE, SEX, EMAIL 會在記憶體裡面 ## 元組 namedtuple 數據結構 from collections import namedtuple ## import collections.namedtuple Student = namedtuple('Student', ['name','age','sex','email']) s = Student('Mike', 16, 'male', 'grama8722@mail.edu.tw') print(s,'\\nNAME: s.name\\n', s.name,'\\nAGE: s.age\\n', s.age) isinstance(s, tuple) ## s是否爲元組 ==\u003e True 所以namedtuple返回確實是元組 del s, Student, namedtuple ","date":"2020-01-31","objectID":"/2020-01-31/:3:3","tags":["python"],"title":"Python 基本","uri":"/2020-01-31/"},{"categories":null,"content":"Day2 ","date":"2020-01-31","objectID":"/2020-01-31/:4:0","tags":["python"],"title":"Python 基本","uri":"/2020-01-31/"},{"categories":null,"content":"找到公共鍵（key） 公共鍵指在多個字典裏面存在相同的鍵（key） 在下面的字典中其中me和K.Gracia就是鍵（key） {'me':12,'K.Gracia':100} 一般寫loop找 使用集合（set）的方式 使用map reduce更快的找到公共鍵 集合下面可以使用 python3 s.items、s.keys、s.values python2 s.viewitems、s.viewkeys、s.viewvalues 在Python寫loop的判斷運算元跟java、c、js不太一樣，ex: ‘||‘要用’or’ Operator (other languages) Operator (Python) \u0026\u0026 and ! not reduce from random import randint, sample sample('abcdefg',3) ## 隨機在abcdefg中產生3個sample sample('abcdefg',randint(3,6)) ## 隨機在abcdefg中產生3~6個sample ## 假設由abcdefg個球員名稱，每一輪的進球數是1~4 ## { for x in sample('abcdefg',randint(3,6)) } ## { x: randint(1,4) for x in sample('abcdefg',randint(3,6)) } s1 = { x: randint(1,4) for x in sample('abcdefg',randint(3,6)) } #第一輪 s2 = { x: randint(1,4) for x in sample('abcdefg',randint(3,6)) } #第二輪 s3 = { x: randint(1,4) for x in sample('abcdefg',randint(3,6)) } #第三輪 print(\"\\n\",s1,\"\\n\",s2,\"\\n\",s3) ### 一般找公共鍵 res = []; for k in s1: if k in s2 and k in s3: res.append(k) pass pass print(\"Loop找公共鍵： \",res) del k ### 使用集合（set）的方式找 直接用 \u0026 或是 | print('集合操作：\\n',s1.keys(),'\\n',s2.keys(),'\\n',s3.keys())## python2用 s1.viewkeys() print(s1.keys() \u0026 s2.keys() \u0026 s3.keys()) ### 如果\"很多集合\"裏面找，可以使用map、reduce mapp = map(dict.keys,[s1,s2,s3]) ## \u003cmap at 0x7f92df970278\u003e print(\"map得到： \\n\", list(mapp)) from functools import reduce ## functools.reduce redd = reduce(lambda a, b: a \u0026 b, map(dict.keys,[s1,s2,s3])) print(\"reduce得到\\n\", redd) ## 其中 lambda a, b: a \u0026 b ==\u003e 前個結果a跟下個結果b交集 del redd, reduce, mapp, s1, s2, s3, res, randint, sample ","date":"2020-01-31","objectID":"/2020-01-31/:4:1","tags":["python"],"title":"Python 基本","uri":"/2020-01-31/"},{"categories":null,"content":"字典排序 希望字典按照輸入順序排序。 使用collection.OrdereDict(python2) ## OrderDict特性 （python2需要） ## from collections import OrderedDict ## d = OrderedDict() d = {} d['Jim'] = (1, 35) d['Leo'] = (5, 356) d['Bob'] = (3, 37) for k in d: print(k) ## 會按照輸入順序 pass del d, k ","date":"2020-01-31","objectID":"/2020-01-31/:4:2","tags":["python"],"title":"Python 基本","uri":"/2020-01-31/"},{"categories":null,"content":"製作歷史記錄（history log） 下面可以發現，如果執行次數多了速度就會變慢很多。 import time from random import randint players = list('ABCDEFGH') ## 8個player start = time.time() for i in range(1,8): ## 執行7次 #input(\"：第%d次：\"% i) p = players.pop( randint( 0,7-i ) ) ## 從列表刪除pop(i)第i個元素，p爲取出的元素 end = time.time() print(i, '刪除： ',p , '取出元素執行時間：', (end-start)*1000,\"ms\") print('列表變爲：', players) pass del players, p, end, start, randint, time 在python 裏面有一個collection.deque的庫可以使用。 例如deque([],5)則可以記錄5個數列更改之前的五個元素。 將其實體化d = deque([],5)，直接使用再append數列的時候同時也對其append即可。 from collections import deque d = deque([],5) a = [1,2,3,4,5] d.extend(a) ## append list中的所有元素時，使用extend print(d) d.append(9) ## 對[1,2,3,4,5]再append一個 '1' print(d) ## 可以發現只剩下五個元素，第一個append的1不會顯示，剩下五個歷史記錄 #要使用直接使用 list(d) 可以直接使用數列 print(list(d)) del d, deque, a 若需要在下面加入歷史記錄的話 from random import randint N = randint(0,5) print(\"答案: \",N) def guess(k): if k == N: print(\"猜對\") return True if k \u003c N: print(\"N比%s還要大\" % k) else: print(\"N比%s還要小\" % k) return False while True: line = input(\"請輸入一個數字： \") if line.isdigit(): k = int(line) if guess(k): ## 執行guess function，猜對跳出 break pass pass pass del k, line, N, randint, guess ## 加入deque歷史記錄 from random import randint from collections import deque ''' 使用pikle的話可以將寫好的資料dump成檔案並儲存 要用的時候可一在別的檔案透過路徑的方式讀取。 類似寫程式的時候把資料存到txt裏面再讀取出來，不過那要writeline 一行一行寫與讀取，這個不用 ''' import pickle ## qq = pickle.load(open('history')) ## 讀取儲存結果 ## qq = pickle.dump(q, open('history','w')) ## 儲存結果 N = randint(0,20) history = deque([],5) print(\"答案: \",N) def guess(k): if k == N: print(\"猜對\") return True if k \u003c N: print(\"N比%s還要大\" % k) else: print(\"N比%s還要小\" % k) return False while True: line = input(\"請輸入一個數字： \") if line.isdigit(): k = int(line) history.append(k) ## 每次輸入一個數字就加入history裏面 if guess(k): ## 執行guess function，猜對跳出 break elif line == 'history' or line == 'h?': print( list(history) ) pass pass del history, line, k, N, pickle, deque, randint, guess ","date":"2020-01-31","objectID":"/2020-01-31/:4:3","tags":["python"],"title":"Python 基本","uri":"/2020-01-31/"},{"categories":null,"content":"Day 3 ","date":"2020-01-31","objectID":"/2020-01-31/:5:0","tags":["python"],"title":"Python 基本","uri":"/2020-01-31/"},{"categories":null,"content":"疊代 iter(x)可以檢查一個東西是否可疊代，iter()可以找到疊代器。 L = [1,2,3,4] s = 'abcdefghijk' print( '疊代器存在：\\n L: ', iter(L),'\\n s: ', iter(s) ) ## 都可以list跟char都可疊代 print( '疊代可實體化：\\n L: ', L.__iter__(),'\\n s: ', s.__iter__() ) ### next()協議在python3變成__next__() it = iter(L) ## print( it.__next__() ) ## 第0個元素 ## print( it.__next__() ) ## 第1個元素 ## print( it.__next__() ) ## 第2個元素 ## print( it.__next__() ) ## 第3個元素 ## print( it.__next__() ) ## 返回StopIteration 然後條錯誤 for _ in range(len(L)): print(it.__next__()) pass del it, L, s ","date":"2020-01-31","objectID":"/2020-01-31/:5:1","tags":["python"],"title":"Python 基本","uri":"/2020-01-31/"},{"categories":null,"content":"curl或是request接收 apis 可以參考其他的api拿到對他們的網址伺服器發出get請求，可以返回資料，然後使用python將其轉換成json的格式，可以對這些資料做類似字典的操作。 這類操作常常要看文檔以及他們的一些檔案格式來做調整。 對HTML內容進行GET請求並且將資料拿下來成JSON之類的可分析格式就是爬蟲了。 ## curl \"http://wthrcdn.etouch.cn/weather_mini?city=\" ### shell命令 import requests def getWeather(city): r = requests.get(u'http://wthrcdn.etouch.cn/weather_mini?city=' + city) data = r.json()['data']['yesterday'] #print(\"資料：\",r.json()) #print(\"昨天資料：\",r.json()['data']['yesterday']) return '%s: %s, %s' % (city, data['low'], data['high']) print(getWeather(u'北京')) print(getWeather(u'上海')) del requests ## function只會返回return的東西喔， 所以r、data都被清掉了 ## 舉個例子，一般是用api的時候會長這樣 import requests url = \"https://weatherbit-v1-mashape.p.rapidapi.com/current\" querystring = {\"lang\":\"en\",\"lon\":\"\u003crequired\u003e\",\"lat\":\"\u003crequired\u003e\"} headers = { 'x-rapidapi-host': \"weatherbit-v1-mashape.p.rapidapi.com\", 'x-rapidapi-key': \"SIGN-UP-FOR-KEY\" } ### 一般的api都需要有api key，通常是需要一些付費或是需要註冊帳號的 ### 自己在自己的電腦寫網頁php、django、tornado、expressJS之類的編寫，也可以透過這個方法得到返回值 response = requests.request(\"GET\", url, headers=headers, params=querystring) print(response) del response, headers, querystring, url, requests ","date":"2020-01-31","objectID":"/2020-01-31/:5:2","tags":["python"],"title":"Python 基本","uri":"/2020-01-31/"},{"categories":null,"content":"封裝（使用疊代器） 可疊代-\u003e批次 首先瞭解什麼是疊代器，在Python中所有的loop疊代，例如for之類的都是透過所謂的next協議去做出來的，包括現在常常被使用的ES6 javascript也是，所以我們可以透過使用疊代器，減少記憶體的使用，因爲Python是一個執行效率不太高的語言。 Python vs C，看完大概就知道使用這個的原因，而且很多框架（framework）也是直接調用next疊代協議（iterator protocol），所以瞭解一點對寫Python會有很多的幫助。 ### 將之前使用的API做封裝成 可疊代物件 import requests from collections import Iterable, Iterator class WeatherIterator(Iterator): ##疊代器 def __init__(self, cities): ### 設定index和cities self.cities = cities self.index = 0 pass def getWeather(self, city): ### 拿資料 r = requests.get(u'http://wthrcdn.etouch.cn/weather_mini?city=' + city) data = r.json()['data']['yesterday'] return '%s: %s, %s' % (city, data['low'], data['high']) def __next__(self): ### next()在python3變成__next__() if self.index == len(self.cities): raise StopIteration ### 錯誤處理 riase（引發）StopIteration錯誤（pyton內建） pass city = self.cities[self.index] self.index += 1 return self.getWeather(city) class WeatherIterable(Iterable): ### 可以疊代物件 def __init__(self,cities): self.cities = cities pass def __iter__(self): return WeatherIterator(self.cities) ### 封裝完畢，實體化來使用，可以對它疊代、批次處理 for x in WeatherIterable([u'北京',u'上海']): print(x) pass del x, Iterable, Iterator, requests ","date":"2020-01-31","objectID":"/2020-01-31/:5:3","tags":["python"],"title":"Python 基本","uri":"/2020-01-31/"},{"categories":null,"content":"錯誤處理 基本 錯誤判斷處理 自己定義錯誤類型 ## Ex1: 基本 try: raise TypeError except TypeError: print('TypeError') ## Ex2: 錯誤判斷處理 def mye( level ): if level \u003c 1: raise Traceback('Hi~Hi') ## 這裏拋出 Traceback不是內建的，會顯示'is not defined' ## 就沒有，印出我們想要定義的錯誤類型 print(\"這裏不執行\") ### 下面是其中一些python有的錯誤類型，下面的程式不執行 raise TypeError('Hi') raise ValueError(\"Hi\") raise NameError('Hi') raise ZeroDivisionError('Hi') pass pass #mye(0) ## 會raise拋出錯誤，error會顯示我們定義的錯誤 try: ## 在c java是try catch、foreach多載之類，用法差不多 mye( 0 ) except Exception as err: ## print出所有錯誤 print(\"44321\",\"Erro {}\".format(err)) pass del mye ## Ex3： 自己定義錯誤類型 class Networkerror(RuntimeError): def __init__(self, arg): self.name = \"Networkerror\" self.args = arg pass pass pass try: raise Networkerror(\"Bad hostname\") except Networkerror as err: print(\"Err \",err.name, '\\n',err. args) ## 作用一樣 \"Erro {}\".format(err)) pass del Networkerror ","date":"2020-01-31","objectID":"/2020-01-31/:5:4","tags":["python"],"title":"Python 基本","uri":"/2020-01-31/"},{"categories":null,"content":"Day 4 ","date":"2020-01-31","objectID":"/2020-01-31/:6:0","tags":["python"],"title":"Python 基本","uri":"/2020-01-31/"},{"categories":null,"content":"yield 產生器（Generator）來做疊代器 yield 產生器使用方法 yield 產生器做成可以疊代的物件 ### 介紹 Python yield Generator 疊代方法 def f(): ## Generator Fcn 這個可以疊代 print('執行 yield 1') yield 1 print('執行 yield 2') yield 2 print('執行 yield 3') yield 3 pass g = f() ## print( g.__next__() ) ## print( g.__next__() ) ## print( g.__next__() ) ## print( g.__next__() ) ## StopIteration會錯誤，跟之前一樣可以用產生器（Generator）器去做 ## ## 第一種 ## for _ in range(3): ## print( g.__next__() ) ## pass ## 可以寫成 for x in g: print(x) pass print( g.__iter__() is g ) ## True =\u003e由於g可以作爲g.__iter__()來調用 del x, g, f class PrimeNumbers: def __init__(self, start, end): ## 建構子 self.start = start self.end = end pass def isPrimeNum(self, k): for i in range(2, k): if k%i == 0: ## k mod i == 0 return False return True pass def __iter__(self): ## 疊代器 for k in range(self.start, self.end + 1): if self.isPrimeNum(k): yield k pass ## pass if pass可以不寫 pass ## pass for pass ## pass fcn pass ## pass class ## 測試封裝完的class y = [] for x in PrimeNumbers(1,100): y.append(x) pass print(y) del y, x, PrimeNumbers ","date":"2020-01-31","objectID":"/2020-01-31/:6:1","tags":["python"],"title":"Python 基本","uri":"/2020-01-31/"},{"categories":null,"content":"反向疊代 ## 反向疊代 L = [1,2,3,4,5] print( 'L[::-1]: ', L[::-1] ) ## 會得到新列表到記憶體 ## reversed() 只有多一個疊代器，不會多一個列表，較好 print( reversed(L) ) y = [] for _ in reversed(L): y.append(_) pass print(y) del y, _, L ### 寫成物件範例 class FloatRange: def __init__(self, start, end, step=0.1): ### 建構子 self.start = start; self.end = end; self.step = step; pass def __iter__(self): t = self.start while t \u003c= self.end: yield t t += self.step pass pass def __reversed__(self): t = self.end while t \u003e= self.start: yield t t -= self.step pass pass pass ## 測試封裝完的class ## 正序 y = [] for x in FloatRange(1.0, 4.0, 0.5): y.append(x) pass print(y) ## 反序 y = [] for x in reversed( FloatRange(1.0, 4.0, 0.5) ): y.append(x) pass print(y) del y, x, FloatRange ","date":"2020-01-31","objectID":"/2020-01-31/:6:2","tags":["python"],"title":"Python 基本","uri":"/2020-01-31/"},{"categories":null,"content":"文件讀取 ope().readlines() 把每個row存到列表中 ## 產生可以讀寫的檔案 ! dmesg \u003e dmessg.log ! find / -name 'dmessg.log' #! cat /content/dmessg.log f = open('/content/dmessg.log') ## readline 讀取太大的文件會浪費太多記憶體 lines = f.readlines() print('f after readlines()會被清空成 list(f)=', list(f)) print(lines[1:10]) ### 用列表的方法可以直接找第1到第10行的數據 ## 在python中可以使用islice 做切片 ## islice(iterable, [start], [stop]) ## 到最後一行stop寫None from itertools import islice #itertools.islice f = open('/content/dmessg.log') ## reandlines()完f = [] y = [] for _ in islice(f,1,10): ## 取出第一行到第十行f的1～10元素就會被拿走了 y.append(_) pass print(y) del y, f ","date":"2020-01-31","objectID":"/2020-01-31/:6:3","tags":["python"],"title":"Python 基本","uri":"/2020-01-31/"},{"categories":null,"content":"並行 使用一個for疊代多個iterable物件 zip 把列表並起來 itertools.chain 把列表串起來 !zip? ## zip 把列表並起來 x = zip([1,2,3,4],('a','b','c','d')) ## 合併兩個列表 y = zip([1,2,3,4],('a','b','c','d'),[7,8,9,10]) ## 合併三個列表 i = zip([1,2,3,4],('a','b','c')) ## 列表len()不一樣合併 print('按照順序抓元素合併包起來\\n' ,'\\n合併2個列表: ',list(x) ,'\\n合併3個列表: ', list(y), '\\n列表len()不一樣合併, 取最大公因數: ',list(i) ) del x, y, i ## zip 範例 from random import randint ## generating data math = [randint(60, 100) for _ in range(40)] ## random the score science = [randint(60, 100) for _ in range(40)] english = [randint(60, 100) for _ in range(40)] ## 處理加總 for i in range(len(math)): math[i] + science[i] + english[i] pass ## 使用zip處理 total=[] #加總 for i,j,k in zip(math, science, english): total.append(i+j+k) pass del math, science, english, i, j, k ## itertools.chain 把列表串起來 from itertools import chain !chain? y = chain([1,2,3,4], ['a','b','c','d']) print(list(y)) y = [] for _ in chain([1,2,3,4], ['a','b','c','d']): y.append(_) pass print(y) del _, y, chain ## 範例 from itertools import chain e1 = [randint(60, 100) for _ in range(40)] e2 = [randint(60, 100) for _ in range(40)] e3 = [randint(60, 100) for _ in range(44)] e4 = [randint(60, 100) for _ in range(39)] ## 找超過90分的數量 count = 0 for s in chain(e1,e2,e3,e4): if s \u003e 90: count += 1 pass pass print('超過90分的數量: ', count) del count, s, e1, e2, e3, e4 ","date":"2020-01-31","objectID":"/2020-01-31/:6:4","tags":["python"],"title":"Python 基本","uri":"/2020-01-31/"},{"categories":null,"content":"Day 5 ","date":"2020-01-31","objectID":"/2020-01-31/:7:0","tags":["python"],"title":"Python 基本","uri":"/2020-01-31/"},{"categories":null,"content":"字串拆分 單一字串 split() 多個字串 re.split('正則表達式', str) ## 處理單一分隔符號 ## 產生可以讀寫的檔案 #! ps aux \u003e psAux.log #! find / -name 'psAux.log' #! cat /content/psAux.log.log ## Linux中的CPU進程PID，系統目錄下面PROC執行中的程序會在上面 !ps aux x = !ps aux s = x[-1] #取出x的最後一行 print('\\n最後一行:\\n', s) print( '\\n以空格方式去分隔:\\n', s.split() ) del s, x ","date":"2020-01-31","objectID":"/2020-01-31/:7:1","tags":["python"],"title":"Python 基本","uri":"/2020-01-31/"},{"categories":null,"content":"map Python3 map() bug 在Function 裡面 map(lambda x: k.extend(x.split(_)), res) 要寫成 list( map(lambda x: k.extend(x.split(_)), res) ) ## map(fcn, iterable)，用法跟filter很像 ## map: convert each item of an array, ## filter: select certain items of an array. ## filter 的fcn要返回True或是False判斷是否留下列表元素 ## map 則是對列表每個元素操作，返回 !map? ## 對每個列表元素做平方 def square(x) : return x ** 2 k = map(square, [1,2,3,4,5]) print(list(k)) del k a = ';/\\,|abcdefghijklmnopqrstuvwxyzABCD' print('使用亂數 a：', a) ## 產生了亂數a，使用 ;/\\,| 分隔 ## 直接使用split的問題 s = ';/\\,|' k = a.split(';'); print( \"\\n第一次拆完之後為二維列表無法直接再直接拆分 a.split(';'):\\n\", k) ## k = k.split('/'); 不能繼續用同樣方法拆 ## map 再切一次 第二次拆分map完的結果list變得更難處理 k = map(lambda x: x.split('/'), k) ## k中的每個元素x拿出來回傳x.split(',') print('\\n第二次拆分map完的結果list變得更難處理\\n', \"map(lambda x: x.split('/'), k):\\n\",list(k)) ## 第二次拆分map完的結果extend到新的list中 k = [] k = a.split(';'); map( lambda x: k.extend( x.split('/') ), k) print('\\n第二次拆分map完的結果extend到新的list中就解決了\\n', \"map( lambda x: k.extend( x.split('/') ), k):\\n\",k) k = [x for x in k if x] print('濾除空字串\\n[x for x in k if x]\\n',k) del k, s, a ","date":"2020-01-31","objectID":"/2020-01-31/:7:2","tags":["python"],"title":"Python 基本","uri":"/2020-01-31/"},{"categories":null,"content":"split()拆分 vs re.split()正則表達式 正則表達式（regulation expression） ## 亂數產生器 from random import randint def makeSalt(lens): strs = ';/\\,|abcdefghijklmnopqrstuvwxyzABCD' salt = '' for i in range(lens): salt += strs[randint(0,31)] pass return salt pass def mySplit(strs, salt): res = [strs] k = [] for _ in salt: k = [] ## python3 function裡面map()外要加上一個list()，不然不會動作 list( map(lambda x: k.extend(x.split(_)), res) ) res = k pass return [x for x in res if x] ##去除空字串 sInput = makeSalt(35) sSalt = ';/\\,|' print( sInput,'\\n', mySplit(sInput, sSalt) ) del sInput, sSalt, makeSalt ## 亂數產生器 from random import randint def makeSalt(lens): strs = ';/\\,|abcdefghijklmnopqrstuvwxyzABCD' salt = '' for i in range(lens): salt += strs[randint(0,31)] pass return salt pass import re ## 正則表達式 !re.split? sInput = makeSalt(35) sSalt = ';/\\,|' print( sInput,\"\\n\\n直接用 re.split(r'[;\\,/|]+', sInput):\\n\",re.split(r'[;\\,/|]+', sInput)) del sInput, sSalt, makeSalt, randint ","date":"2020-01-31","objectID":"/2020-01-31/:7:3","tags":["python"],"title":"Python 基本","uri":"/2020-01-31/"},{"categories":null,"content":"判斷字串開頭結尾字符 bassic2.ipynb 從這裡開始繼續下個檔案會重新說過 char.startswith()、char.endswith()，只能傳入字串或是元組 #!ls -lh sample_data import os k = os.listdir('sample_data') ## char.startswith()、char.endswith() s = 'california_housing_test.csv' print(\"s =\", s) print(\"s.endswith('.csv') =\u003e\", s.endswith('.csv') ) print(\"s.endswith('.py') =\u003e\",s.endswith('.py'),'\\n' ) ## 所以可以寫成 s =[name for name in k if name.endswith( ('.md', '.json'))] ## 輸出name（最前面的），for name in k，if判斷k的第name個元素endswith（（'', '',''）） print('os.listdir(): \\n',k) print(\"濾出 *.md *.json :\\n\",s) del k, s, os ## 把 *.txt 檔案全部改成 *.m 的格式 import os path = './' f = os.listdir(path) out = [x for x in f if x.endswith('.txt')] n = 0; i = 0 for i in out: ## 設定舊檔名（就是路徑+檔名） oldname = out[n] k = len(out[n])-4 ## 設定新檔名 newname = out[n][0:k] + '.m' ## 用os模組中的rename方法對檔案改名 os.rename(path+oldname, path+newname) print(oldname, '======\u003e', newname) n += 1 pass #!ls -lh sample_data import os, stat ## stat是掩碼庫 k = os.stat('sample_data/README.md') print('資料：\\n',k) k = os.stat('sample_data/README.md').st_mode ## oct 八進制 print('掩碼：\\n',k) k = oct(k) print('權限知道權限755: \\n',k) ## 修改Linux權限 ## stat.S_IXUSR 掩碼AND權限 =\u003e 權限755, 最上面的group會加上可執行權限(x,rwx) ## os.chmod('sample_data/README.md', os.stat('sample_data/README.md').st_mode | stat.S_IXUSR) del k, os, stat ","date":"2020-01-31","objectID":"/2020-01-31/:7:4","tags":["python"],"title":"Python 基本","uri":"/2020-01-31/"},{"categories":null,"content":"Part II ","date":"2020-01-31","objectID":"/2020-01-31/:8:0","tags":["python"],"title":"Python 基本","uri":"/2020-01-31/"},{"categories":null,"content":"判斷字串 可傳入元組 str.startwith() str.endwith() # generate testing dir file !if [ -d \"test\" ]; then rm -rf test; fi ! mkdir test \u0026\u0026 cd test \u0026\u0026 touch a.sh b.py c.h d.java e.py f.cpp \u0026\u0026 ls -lh import os, stat os.listdir('./test') s = 'g.sh' print( \"s = 'g.sh', s.endswith: \",s.endswith('.sh') ) # 篩選 print(\"\\n列表comprehension, \\n [ name for name in os.listdir('./test') if name.endswith(('.sh', '.py')) ])\") [ name for name in os.listdir('./test') if name.endswith(('.sh', '.py'))] del s, os, stat ","date":"2020-01-31","objectID":"/2020-01-31/:9:0","tags":["python"],"title":"Python 基本","uri":"/2020-01-31/"},{"categories":null,"content":"修改權限 修改成其他權限可參考 os.stat(‘filepath’) os.stat(‘filepath’).st_mode os.chmod(‘file’, os.stat(‘file’).st_mode | stat.S_IXUSR ) os.chmod(檔案路徑, 檔案的stat與掩碼做OR的結果) python stat doc import os, stat os.listdir('./test') # 修改執行權限 755 644 使用遮罩掩碼做OR去改 os.stat('./test/e.py') os.stat('./test/e.py').st_mode print(\"\\nos.stat:\\n%s\\nos.stat.st_mode: %s =\u003e 這個是二進制數值\\n轉換成八進制oct(): %s =\u003e看得出來是644的權限（user gourp other三位元權限u+g+o）\\n\" % ( os.stat('./test/e.py'),os.stat('./test/e.py').st_mode , oct(os.stat('./test/e.py').st_mode)), \"每個用戶組分別有read-write-execute 可執行、可讀、可寫三種權限，基本Linux\" ) !ls -lh ./test | grep \"e.py\" os.chmod('./test/e.py', os.stat('./test/e.py').st_mode | stat.S_IXUSR ) !ls -lh ./test | grep \"e.py\" del os, stat ","date":"2020-01-31","objectID":"/2020-01-31/:10:0","tags":["python"],"title":"Python 基本","uri":"/2020-01-31/"},{"categories":null,"content":"替換文檔格式，格式處理 使用正則表達式，進行處理 替換 re.sub() # !find / -name dpkg.log # /var/log/dpkg.log # !cat /var/log/dpkg.log | less #more print('看前十個資料，要改變日期格式') !if [ -d \"test\" ]; then rm -rf test; mkdir test; fi !cat /var/log/dpkg.log \u003e\u003e ./test/dpkg.log # !head 10 ./test/dpkg.log print('\\n用python') # log = open('/var/log/dpkg.log').read() # readall log = open('/var/log/dpkg.log') #.readline() 執行一次迭代器+1 讀出一行 y = '' for i in range(10): #x = log.readline().rstrip(\"\\n\") # print 會自動加入 \\n x = log.readline() y = x + y pass print(y) import re # 正則表達式 #!re.sub? # 描述日期格式 \\d{4} \\d{2} \\d{2} 用()把三組圈起來 a = re.sub('(\\d{4})-(\\d{2})-(\\d{2})', '\\1' , y) # '\\1\\2' 表示第一組跟第二組 b = re.sub('(\\d{4})-(\\d{2})-(\\d{2})', '\\1-\\2' , y) # r'\\1\\2' 原始字串 c = re.sub('(\\d{4})-(\\d{2})-(\\d{2})', r'\\1-\\2' , y) print( \"\\na: \\1': \\n%s \\nb: '\\1\\2': \\n%s \\nc: 使用原始字串的話長度不會因爲正規改變(可能會像是a、b一樣有格式問題)r'\\1\\2': \\n%s \" % (a,b,c) ) # 知道上面就可以知道 ==\u003e r'\\2 / \\3 / \\1' 三組之間用/隔開 d = re.sub('(\\d{4})-(\\d{2})-(\\d{2})', r'\\2/\\3/\\1' , y) print(\"\\nd: r'\\2/\\3/\\1': \\n%s \" % d) # 可以對每個組定義名稱一樣的結果可以寫成下面 每個組( ?P\u003cname\u003e\\d{} ), 然後建構就用\\g\u003cname\u003e e = re.sub('(?P\u003cyear\u003e\\d{4})-(?P\u003cmonth\u003e\\d{2})-(?P\u003cday\u003e\\d{2})', r'\\g\u003cmonth\u003e/\\g\u003cday\u003e/\\g\u003cyear\u003e' , y) print(\"\\nd: 每個組( ?P\u003cname\u003e\\d{} ), 然後建構就用\\g\u003cname\u003e: \\n%s \" % e) del a,b,c,d,e,re,x,y ","date":"2020-01-31","objectID":"/2020-01-31/:11:0","tags":["python"],"title":"Python 基本","uri":"/2020-01-31/"},{"categories":null,"content":"字串拼接 ‘+’ ‘分隔符號’.join(list) ：list可以是comprehension s1 = 'abcdefg' s2 = '12345' # 拼起來 print (\"s = s1 + s2 '+' ： %s\" %s1+s2 ) print(\"str.__add__(s1,s2) :%s\" %str.__add__(s1,s2) ) print(\"s1 \u003e s2: %s\" % (s1\u003es2) ) print(\"str.__gt__(s1,s2): %s\" %(str.__gt__(s1,s2)) ) pl = [\"\u003c0112\u003e\", \"\u003c32\u003e\", \"\u003c1024x768\u003e\", \"\u003c60\u003e\", \"\u003c1\u003e\", \"\u003c100.0\u003e\", \"\u003c500.0\u003e\"] s = '' for _ in pl: ## 列表很長會有記憶體浪費 s+=_ pass ''.join(pl) ## 這會比較好 (以空字串分隔) print(\"''.join(pl): %s \\n ';'.join(pl): %s \" %(''.join(pl), ';'.join(pl))) # 使用列表 ''.join([str(x) for x in pl]) # 列表[]會創建列表到記憶體 ''.join(str(x) for x in pl) # 產生器這個比較好 del s1,s2,pl ","date":"2020-01-31","objectID":"/2020-01-31/:12:0","tags":["python"],"title":"Python 基本","uri":"/2020-01-31/"},{"categories":null,"content":"對齊字串 str.ljust(), str.rjust(), str.center() 左右中對齊 format(,\u003c\u003e^) print 字典的時候也可以用 s = 'abc' a = s.ljust(20,'=') b = s.rjust(20,'=') c = s.center(20,'=') print(\"\\nljust(): \\n%s\\nrjust(): \\n%s\\ncenter(): \\n%s\" %(a,b,c)) a = format(s, '\u003c20') b = format(s, '\u003e20') c = format(s, '^20') print(\"\\nformat(s, '\u003c20'): \\n%s\\nformat(s, '\u003e20'): \\n%s\\nformat(s, '^20'): \\n%s\" %(a,b,c)) d = { \"lodDict\":100.0, \"SmallCull\": 0.04, \"DistCull\": 500.0, \"trilinear\": 40, \"farclip\": 477 } d.keys() map(len, d.keys()) max(map(len,d.keys())) w = max(map(len,d.keys())) print(\"\\n對齊字典\\n\") for k in d: #到冒號之前對齊，用最長的長度w去對齊 print( k.ljust(w),':',d[k]) pass del a,b,c,d,w,s ","date":"2020-01-31","objectID":"/2020-01-31/:13:0","tags":["python"],"title":"Python 基本","uri":"/2020-01-31/"},{"categories":null,"content":"字串去除 strip()、lstrip()、rstrip() ‘+’、[:end] replace() replace()、re.sub translate() # strip() lstrip() rstrip() s = ' ======abc ++ 123 -- ' a = s.strip() b = s.lstrip() c = s.rstrip() print( \" s: %s\" %s, \"\\n s.strip() 除掉兩邊空白: %s \\n s.strip() 除掉左邊空白: %s \\n s.strip() 除掉右邊邊空白: %s\" %(a,b,c)) d = s.strip().strip('-=') print(\" s.strip().strip('-=') 去除前後空白再去處前後-=: %s\" %d) del a,b,c,d,s s = 'abc:123' a = s[:3] + s[4:] print(\"s: %s \\n s[:3] + s[4:]: %s\" %(s,a)); del s,a # replace() re.sub() '\\' print 不太出來 s = \"\\tabc\\t123\\txyz\\ropq\\r\" a = s.replace('\\t', '') import re b = re.sub('[\\t\\r]', '', s) print(\"s: %s \\n s.replace('\\t', ''): %s \\n re.sub('[\\t\\r]', '', s): %s\" %(s,a,b)); del s,a,b # str.translate() unicode.translate() s = 'abc1230323xyz' # 假設有一個加密是將上面abc-\u003exyz，xyz-\u003eabc import string a = s.maketrans('abcxyz', 'xyzabc') # 產生mapping 映射表 b = s.translate(a) print(' s:',s,'\\n mapping:',a,'\\n 轉換結果：',b) ","date":"2020-01-31","objectID":"/2020-01-31/:14:0","tags":["python"],"title":"Python 基本","uri":"/2020-01-31/"},{"categories":null,"content":"It's a example","date":"2020-01-18","objectID":"/2020-01-18/","tags":["duelboot","manjaro","windows","macos"],"title":"Manjaro 雙系統安裝","uri":"/2020-01-18/"},{"categories":null,"content":"切出空間 在Windows或是其他系統中分割出空間，在Windows管理下面壓縮磁區，或是在MacOS上面建立FAT32的磁區。 ","date":"2020-01-18","objectID":"/2020-01-18/:1:0","tags":["duelboot","manjaro","windows","macos"],"title":"Manjaro 雙系統安裝","uri":"/2020-01-18/"},{"categories":null,"content":"安裝 在EFI磁區加入掛載點: /boot/efi flag選: boot esp 剩下的磁區分割就剩下: ext4 /, flag: root ext4 /home, flag home linuxswap, flag: swap 說一下我的分割方式，我是直接全部切50G全部給/、root。 由於Linux其實不用swap也可以運作，所以就沒有切了，如果記憶體真的比較小的舊電腦，還是建議切幾個GB給SWAP。 ","date":"2020-01-18","objectID":"/2020-01-18/:2:0","tags":["duelboot","manjaro","windows","macos"],"title":"Manjaro 雙系統安裝","uri":"/2020-01-18/"},{"categories":null,"content":"NTFS、APFS讀取問題 ","date":"2020-01-18","objectID":"/2020-01-18/:3:0","tags":["duelboot","manjaro","windows","macos"],"title":"Manjaro 雙系統安裝","uri":"/2020-01-18/"},{"categories":null,"content":"Windows 要關掉電源的像是Fast startup、Hybrid Sleep的設定，不然就算有ntfs-3g，在Linux上面也沒有硬碟的寫入權限，只能讀取。 在Power shell上打入 REG ADD \"HKLM\\SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Power\" /V HiberbootEnabled /T REG_dWORD /D 0 /F 現在在Linux上也可以解決這個問題，但是應該還是在Windows解決比較對，除非已經安裝成完全爲Linux 在Linux上使用ntfsprogs工具可以解決這個問題 df -lh # 查看設備容量 sudo ntfsfix /dev/sda ","date":"2020-01-18","objectID":"/2020-01-18/:3:1","tags":["duelboot","manjaro","windows","macos"],"title":"Manjaro 雙系統安裝","uri":"/2020-01-18/"},{"categories":null,"content":"MacOS 插上電源，關閉FileVault。 然後到Linux系統下： 安裝 apfs-fuse apfs比較麻煩的地方是不會自動掛載，要打指令，這個應該可以使用別的方法解決。 反正就暫時記錄如何掛載。 ~ sudo fdisk -l # 我的apfs在sda2 mkdir macos sudo apfs-fuse -o allow_other /dev/sda2 ~/macos 有人說需要把linux efi驅動覆蓋一次，到apple的驅動，我是覺得不用。 EFI driver\r","date":"2020-01-18","objectID":"/2020-01-18/:3:2","tags":["duelboot","manjaro","windows","macos"],"title":"Manjaro 雙系統安裝","uri":"/2020-01-18/"},{"categories":["Linux"],"content":"It's a example","date":"2020-01-13","objectID":"/2020-01-13/","tags":["jack2","audio"],"title":"Jack2+cadence 低延遲輸出","uri":"/2020-01-13/"},{"categories":["Linux"],"content":"安裝Jack2、qJackCtl、cadence 我是使用Manjaro community的版本。 然後打開qjackCtl設備調整成地延遲的DAC設備。 qjqckCtl設定\r再來設定cadence ！ ！ 另外如果之後重新開機之後如果cadence沒有啟動的話，可以試試看這個指令： cadence-session-start --system-start ","date":"2020-01-13","objectID":"/2020-01-13/:1:0","tags":["jack2","audio"],"title":"Jack2+cadence 低延遲輸出","uri":"/2020-01-13/"},{"categories":["Linux"],"content":"airwave 和 windws vst 首先必須先在wine的系統裡面安裝windows的vst。 wine xxx.exe mv plugin ~/.wine/drive_c/plugins #*.dll vst file if have 再來就是airwave wine plugin了 airwave 設定\r其中有兩個東西要設定，分別是VST plugin和Link location VST plugin就是你VST plugin的*.dll的檔案 Link location則是airwave要在哪裡給DAWs存取。 例如我設定在/home/geek/.vst，DAWs就要在這裡找plugin，下面是Tracktion 7 的例子 加入vst路徑\r","date":"2020-01-13","objectID":"/2020-01-13/:2:0","tags":["jack2","audio"],"title":"Jack2+cadence 低延遲輸出","uri":"/2020-01-13/"},{"categories":null,"content":"It's a example","date":"2020-01-11","objectID":"/2020-01-11/","tags":["hugo","mathjax"],"title":"從Hexo到Hugo","uri":"/2020-01-11/"},{"categories":null,"content":"原因 隨着文章增加，雖然沒有些什麼東西，漸漸的發現在靜態檔案轉換的速度漸漸的變慢了，發現Hexo的速度以及它plugin過度依賴的問題太過於明顯，前一陣子因為plugin的問題弄了很久，放假時間就試着使用hugo了。 之前使用的是Hexo-NexT的主題，就不介紹了，是一個我很喜歡的主題，有我喜歡的Local Search的功能，也不知道為什麼很多的都不寫，雖然網路上看到一些高手想到的解決方案，但是如果可以直接有的主題還是我的首選，所以我就使用hugo-theme-pure了。 下面是我轉到Hugo下面的主題架構檔案大小，之前用Hexo的時候，檔案非常難以移動，現在比較好搬動了，下面的檔案大小還是我將轉出來的public，也就是上傳到github page的部分刪掉的大小，相對而言，Hugo實在是優秀太多了，只是hexo對剛開始使用的人真的也是非常友好，上傳github有hexo d的指令可以使用，如果用hugo的話，就要自己重新add remote xx.git，然後重新add、commit、push一次。 檔案比較\r這篇文章大概整理一下換hugo使用的過程遇到的地方。 ","date":"2020-01-11","objectID":"/2020-01-11/:1:0","tags":["hugo","mathjax"],"title":"從Hexo到Hugo","uri":"/2020-01-11/"},{"categories":null,"content":"hugo 安裝 我在Manjaro linux上面使用，所以直接在Add/Remove Software加上去就解決了。不過官方也有說怎麼做安裝的動作，Windows用Chocolatey，Macos用Homebrew。 現在的Loveit在新版本會有一些問題，所以需要安裝\u003c=0.74.3的版本，在window上面安裝的話可以使用choco版本安裝工具部署 當然在Linux上，例如滾動式更新的Manjaro之類的可能找不到相應版本，所以需要去尋求Github的原始版本，不過還好，Release上面有building的執行檔 choco install hugo --version=0.74.3 choco install hugo-extended --version=0.74.3 ## 加入Linux 環境變量 export PATH=/home/$USER/hugo:$PATH source ~/.zshrc ～ $ hugo new site site_name $ cd site_name/themes $ git clone https://github.com/xiaoheiAh/hugo-theme-pure.git pure $ cd ~/site_name $ cp site_name/themes/exampleSite/config.yml config.yml $ hugo server ","date":"2020-01-11","objectID":"/2020-01-11/:2:0","tags":["hugo","mathjax"],"title":"從Hexo到Hugo","uri":"/2020-01-11/"},{"categories":null,"content":"上傳到之前的 github page 首先是這個theme的設定檔案./config.yml的baseURL要填入你的github page的網址，hugo官方也有提到相關的問題，如果沒有加入的話會導致css無法讀取，踩過地雷，記錄一下。 baseURL: https://xxxxxxx.github.io theme: pure title: Pure theme for Hugo defaultContentLanguage: zh # en/zh/... footnoteReturnLinkContents: ↩ hasCJKLanguage: true paginate: 7 enableEmoji: true PygmentsCodeFences: false googleAnalytics: \"UA-97401827-1\" # UA-XXXXXXXX-X permalinks: posts: /:year/:month/:filename/ 首先假設你已經設定好github的指令，其實就是把.git隱藏資料架拿來。 用clone的方式 cd site_name \u0026\u0026 rm -rf public git clone https://www.gitxxx/xxx/xxx.git mv xxx.github.io public \u0026\u0026 hugo cd public \u0026\u0026 git add. \u0026\u0026 git commit -m \"add\" git push -u origin master 另一種 cd site_name/public git init git remote -v # 有的話就不用加了 git remote add origin https://www.gitxxx/xxx/xxx.git git pull \u0026\u0026 hugo ## 要先拉再推 git add . git commit -m \"update to hugo from hexo\" git push -u origin master # 還是不行就加-f ","date":"2020-01-11","objectID":"/2020-01-11/:3:0","tags":["hugo","mathjax"],"title":"從Hexo到Hugo","uri":"/2020-01-11/"},{"categories":null,"content":"Disqus pure的disqus不能用，./config.yml的地方要把disqus註解掉，按照官方的做法去做。 # 手動加入disque，/layouts/partials/: 裡新增 disqus.html # /layouts/partials/article: # \u003cdiv class=\"disqus markdown\"\u003e # {{ partial \"disqus.html\" . }} # \u003c/div\u003e # Comment comment: type: #disqus # type disqus/gitalk/valine 启用哪种评论系统 disqus: #xxxxxxxx # enter disqus shortname here disqusShortname: shortname 然後手動加入disqus，/layouts/partials/ 裡新增 disqus.html \u003cdiv id=\"disqus_thread\"\u003e\u003c/div\u003e \u003cscript type=\"text/javascript\"\u003e console.log('{{ .Site.DisqusShortname }}'); (function() { // if (window.location.hostname == \"localhost\") // return; var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true; var disqus_shortname = '{{ .Site.DisqusShortname }}'; dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js'; (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq); })(); \u003c/script\u003e \u003cnoscript\u003ePlease enable JavaScript to view the \u003ca href=\"http://disqus.com/?ref_noscript\"\u003ecomments powered by Disqus.\u003c/a\u003e\u003c/noscript\u003e \u003ca href=\"http://disqus.com/\" class=\"dsq-brlink\"\u003ecomments powered by \u003cspan class=\"logo-disqus\"\u003eDisqus\u003c/span\u003e\u003c/a\u003e 再來在/layouts/partials/article的\u003c/article\u003e ，加載在之前的pure做的comment的位置就行了 ","date":"2020-01-11","objectID":"/2020-01-11/:4:0","tags":["hugo","mathjax"],"title":"從Hexo到Hugo","uri":"/2020-01-11/"},{"categories":null,"content":"hugo mathjax顯示 有些themes沒有辦法辨識mathjax，通常這樣可以解決，我用的theme不用作者有做了。 在themes/theme-name/layouts/head.html貼上 \u003cscript type=\"text/javascript\" async src=\"https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML\"\u003e MathJax.Hub.Config({ tex2jax: { inlineMath: [['$','$'], ['\\\\(','\\\\)']], displayMath: [['$$','$$']], processEscapes: true, processEnvironments: true, skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'], TeX: { equationNumbers: { autoNumber: \"AMS\" }, extensions: [\"AMSmath.js\", \"AMSsymbols.js\"] } } }); MathJax.Hub.Queue(function() { // Fix \u003ccode\u003e tags after MathJax finishes running. This is a // hack to overcome a shortcoming of Markdown. Discussion at // https://github.com/mojombo/jekyll/issues/199 var all = MathJax.Hub.getAllJax(), i; for(i = 0; i \u003c all.length; i += 1) { all[i].SourceElement().parentNode.className += ' has-jax'; } }); MathJax.Hub.Config({ // Autonumbering by mathjax TeX: { equationNumbers: { autoNumber: \"AMS\" } } }); \u003c/script\u003e ","date":"2020-01-11","objectID":"/2020-01-11/:5:0","tags":["hugo","mathjax"],"title":"從Hexo到Hugo","uri":"/2020-01-11/"},{"categories":null,"content":"自動跳文章目錄 在pure/assets/js/application.js，23行左右加入，最後我也拿掉了，感覺沒什麼用 $('#collapseToc').on('shown.bs.collapse', function() { // do something… // slimscroll if (typeof $.fn.slimScroll != 'undefined') { $(\".sidebar .slimContent\").slimScroll().on('slimscroll'); } }); // s 自動切換至 文章目錄（用toc-list), // tocbot.init在/theme/layout/partial/script.html裏面設定 //$('.collapse').collapse() $('#collapseToc.collapse').collapse() ","date":"2020-01-11","objectID":"/2020-01-11/:6:0","tags":["hugo","mathjax"],"title":"從Hexo到Hugo","uri":"/2020-01-11/"},{"categories":null,"content":"It's a example","date":"2019-06-28","objectID":"/2020-06-28/","tags":["hugo"],"title":"ShortCode 整理","uri":"/2020-06-28/"},{"categories":null,"content":"\r整理一下最近加入的shortcode，{{}}會錯誤所以都用{}代替，不然會變成這樣，今天換了Loveit發現主題內建了mermaid，所以就改檔案名，暫時擺著，順便加上Loveit有的shortcode，文檔有蠻多可以用的，就去不全部放了。 ","date":"2019-06-28","objectID":"/2020-06-28/:0:0","tags":["hugo"],"title":"ShortCode 整理","uri":"/2020-06-28/"},{"categories":null,"content":"Mindmap {\u003c mind \u003e} - 根目錄 - 一級目錄1 - 二級目錄1 - 二級目錄2 - 一級目錄2 {\u003c /mind \u003e} 根目录 一級目錄1 二級目錄1 二級目錄2 一級目錄2 unordered-list-to-mind-map放到/static/mind/目錄下面，然後加入/layouts/shortcodes/mind.html的全局shortcode，關於這個shortcode我要說一下，在我這裡{{ .Inner }}不行用，要用{{ .Inner | markdownify }}，就看一下結果就知道了，就mindmap.js檔案寫的內容，如果可以改用#更好，不過\u003ch1\u003e\u003ch2\u003e\u003ch3\u003e這種tag看起來寫起來就很麻煩。 Inner\rInner markdown\r\u003c!-- from https://github.com/HunterXuan/unordered-list-to-mind-map --\u003e \u003cdiv id=\"{{ .Get 0 }}\" class=\"mindmap mindmap-lg\" style=\"width:100%;height:300px;border:3px #cccccc dashed;\"\u003e {{ .Inner | markdownify }} \u003c/div\u003e \u003cscript src=\"https://code.jquery.com/jquery-3.3.1.min.js\"\u003e\u003c/script\u003e \u003cscript src=\"/mind/jquery-3.3.1.min.js\"\u003e\u003c/script\u003e \u003clink href=\"/mind/mindmap.css\" rel=\"stylesheet\"\u003e \u003cscript src=\"/mind/kity.min.js\"\u003e\u003c/script\u003e \u003cscript src=\"/mind/kityminder.core.min.js\"\u003e\u003c/script\u003e \u003c!-- \u003cscript src=\"/mind/mindmap.min.js\"\u003e\u003c/script\u003e --\u003e \u003c!-- minder 重複加載會顯示我們不想要的結果選一個不加載或是直接刪除檔案 --\u003e \u003c!-- \u003cscript src=\"/mind/mindmap.js\"\u003e\u003c/script\u003e --\u003e 再來就是mindmap.js重複加載的問題，這個檔案重複加載，也就是畫了兩個圖會出現問題，直接變成四個圖，所以要處理一下，出現了圖重複的狀況。 我是直接對kityminder、kitty這兩個物件名稱做判斷（在瀏覽器找到就直接用了），原因就是每次會用到它的時候大概也是用在這裡，不過似乎不行，可能跟hugo的內部執行順序有關，所以最後還是加到theme裡面，我自己是加載在theme/layout/posts/single.html的\u003c/article\u003e上面一點的地方。 \u003cscript\u003e if (typeof jQuery != \"undefined\" || typeof kityminder != \"undefined\") { // do something 不能用document.write var s=document.createElement('script'); s.src='/mind/mindmap.min.js'; document.body.appendChild(s); } \u003c/script\u003e ","date":"2019-06-28","objectID":"/2020-06-28/:1:0","tags":["hugo"],"title":"ShortCode 整理","uri":"/2020-06-28/"},{"categories":null,"content":"Typeit 打字 TypeIt 的 打字動畫 的 段落…| {\u003c typeit \u003e} 打字 [TypeIt](https://typeitjs.com/) 的 **打字動畫** 的 *段落*... {\u003c /typeit \u003e} {\u003c typeit code=java \u003e} public class HelloWorld { public static void main(String []args) { System.out.println(\"Hello World\"); } } {\u003c /typeit \u003e} 下面用 {\u003c typeit code=C# \u003e}，{\u003c typeit code=python \u003e} 測試 ","date":"2019-06-28","objectID":"/2020-06-28/:2:0","tags":["hugo"],"title":"ShortCode 整理","uri":"/2020-06-28/"},{"categories":null,"content":"Plotly {\u003c plotly ns3_ofdm_yans_wifi_model_subplot \u003e} ","date":"2019-06-28","objectID":"/2020-06-28/:3:0","tags":["hugo"],"title":"ShortCode 整理","uri":"/2020-06-28/"},{"categories":null,"content":"Music use Roland JV-1080 vst, kontakt somthing wrong add other kontakt with Roland JV-1080 vst {\u003c music url=\"/audio/abelton_remix.wav\" name=\"Remix from abelton Live\" artist=NaN cover=\"/cover/avator.jpg\" \u003e} ","date":"2019-06-28","objectID":"/2020-06-28/:4:0","tags":["hugo"],"title":"ShortCode 整理","uri":"/2020-06-28/"},{"categories":null,"content":"Mapbox 再找個時間看一下語言設定，座標與Google Map複製的座標貼上順序相反。 {\u003c mapbox 121.56061923804162 25.04417192846157 10 false \"mapbox://styles/mapbox/streets-zh-v1\" \u003e} Zh style {\u003c mapbox -122.252 37.453 10 false \"mapbox://styles/mapbox/streets-zh-v1\" \u003e} Eng style {\u003c mapbox -122.252 37.453 10 false \"mapbox://styles/mapbox/streets-v11\" \u003e} ","date":"2019-06-28","objectID":"/2020-06-28/:5:0","tags":["hugo"],"title":"ShortCode 整理","uri":"/2020-06-28/"},{"categories":null,"content":"MS view \u003cbr\u003e \u003ciframe src='https://view.officeapps.live.com/op/embed.aspx?src=your_URL' width='98%' height='500px' frameborder='0'\u003e \u003c/iframe\u003e \u003cbr\u003e Office file (’.ppt’ ‘.pptx’ ‘.doc’, ‘.docx’, ‘.xls’, ‘.xlsx’) ","date":"2019-06-28","objectID":"/2020-06-28/:6:0","tags":["hugo"],"title":"ShortCode 整理","uri":"/2020-06-28/"},{"categories":null,"content":"Google View \u003cbr\u003e \u003ciframe src='https://docs.google.com/viewer?url=you_URL\u0026embedded=true' width='98%' height='700px' frameborder='0'\u003e \u003c/iframe\u003e \u003cbr\u003e Image files (.JPEG, .PNG, .GIF, .TIFF, .BMP) Video files (WebM, .MPEG4, .3GPP, .MOV, .AVI, .MPEGPS, .WMV, .FLV) Text files (.TXT) Markup/Code (.CSS, .HTML, .PHP, .C, .CPP, .H, .HPP, .JS) Microsoft Word (.DOC and .DOCX) Microsoft Excel (.XLS and .XLSX) Microsoft PowerPoint (.PPT and .PPTX) Adobe Portable Document Format (.PDF) Apple Pages (.PAGES) Adobe Illustrator (.AI) Adobe Photoshop (.PSD) Tagged Image File Format (.TIFF) Autodesk AutoCad (.DXF) Scalable Vector Graphics (.SVG) PostScript (.EPS, .PS) TrueType (.TTF) XML Paper Specification (.XPS) Archive file types (.ZIP and .RAR) ","date":"2019-06-28","objectID":"/2020-06-28/:7:0","tags":["hugo"],"title":"ShortCode 整理","uri":"/2020-06-28/"},{"categories":null,"content":"It's a example","date":"2019-02-18","objectID":"/2019-02-18/","tags":["git"],"title":"Git 使用","uri":"/2019-02-18/"},{"categories":null,"content":"編輯現有的project git clone https://www.gitxxx/xxx/xxx.git ## 編輯完之後上傳 git add . git commit -m \"commit message 可以寫做什麼修改\" ## 上傳 git push -u orgin master ## push 到叫做orgin的xxx.git ","date":"2019-02-18","objectID":"/2019-02-18/:1:0","tags":["git"],"title":"Git 使用","uri":"/2019-02-18/"},{"categories":null,"content":"檢查要push的地方 git remote -v origin git@gitxxx.com:xxx/xxx.git (fetch) origin git@gitxxx.com:xxx/xxx.git (push) ## 上傳到別的位置 git remote add new_one https://www.gitxxx/xxx/xxx.git git remote -v new_one git@gitxxx.com:xxx/xxx.git (fetch) new_one git@gitxxx.com:xxx/xxx.git (push) origin git@gitxxx.com:xxx/xxx.git (fetch) origin git@gitxxx.com:xxx/xxx.git (push) ## 如果有新的commit的話可以使用 git push -u orgin master git push -u new_one master ","date":"2019-02-18","objectID":"/2019-02-18/:2:0","tags":["git"],"title":"Git 使用","uri":"/2019-02-18/"},{"categories":null,"content":"使用Git的好處 可以檢閱各個版本的差別，最近發現vs code還有一個git的功能，就像下圖所示的，可以查看上個版本刪減增加的內容。 Git Log on vscode\rGit的基本使用方法非常簡單，首先要先在github或是gitlab創建賬號，然後設定好ssh連線，在這之前要安裝並且設定git 建立Repository\rGitlab Guide\r","date":"2019-02-18","objectID":"/2019-02-18/:3:0","tags":["git"],"title":"Git 使用","uri":"/2019-02-18/"},{"categories":null,"content":"Git 初始設定 這個地方要設定你git代碼託管的username以及email，你班在創建完git網頁上的賬號之後，可以在profile的地方看到，你的fullname和email。 git config --global user.name \"git_username\" git config --global user.email \"git_email\" SSH 設定 再來是設定SSH的部分，如果不是要設定多個SSH連線，可以不用建立config檔案 sudo apt-get install ssh touch ~/.ssh/config # 給與shell執行權限 sudo chmod 755 ~/.ssh # 解決連線permission問題 編輯~/.ssh/config # Github Host github.com HostName github.com PreferredAuthentications publickey IdentityFile ~/.ssh/id_rsa # Gitlab Host gitlab.com HostName gitlab.com PreferredAuthentications publickey IdentityFile ~/.ssh/id_ed25519 然後重新啓動SSH ## 重啓ssh sudo service ssh restart # ubuntu centos sudo systemctl restart sshd.service # arch manjaro # macOS sudo launchctl stop com.openssh.sshd sudo launchctl start com.openssh.sshd ","date":"2019-02-18","objectID":"/2019-02-18/:4:0","tags":["git"],"title":"Git 使用","uri":"/2019-02-18/"},{"categories":null,"content":"建立SSH KEY Github和Gitlab都有介紹如何建立ssh連線，照着操作就行了，只要記得把設定檔IdentityFile輸對就行了。 Add SSH key\r最後，再測試看看連線 ssh -T git@gitlab.com Welcome to GitLab, @shihchun! ssh -T git@github.com Hi shihchun! You've successfully authenticated, but GitHub does not provide shell access. ","date":"2019-02-18","objectID":"/2019-02-18/:5:0","tags":["git"],"title":"Git 使用","uri":"/2019-02-18/"},{"categories":null,"content":"It's a example","date":"2018-10-30","objectID":"/2018-10-30/","tags":["vm","kvm","libvirt","qemu"],"title":"KVM安裝","uri":"/2018-10-30/"},{"categories":null,"content":"KVM (Kernel-based Virtual Machine) is a virtuallation ifrastructure for the Linux that turns the Linux kernel into a hypervisor. ….Libvirt可以管理KVM，透過甚至Libvirt可以使用Openstack做雲端計算，實現位置監控以及自動化 KVM\r","date":"2018-10-30","objectID":"/2018-10-30/:0:0","tags":["vm","kvm","libvirt","qemu"],"title":"KVM安裝","uri":"/2018-10-30/"},{"categories":null,"content":"How it works It works with GNU / LINUX User Space Kernel Space # top 而KVM的虛擬機virtual machine就是透過QEMU去做安裝的，如果要使用虛擬機KVM的話用像VMware一樣有嵌套虛擬化的VM工具，可以在虛擬機下面執行虛擬機，還有V-td（Intel）的功能也要打開，AMD系列主機板則是AMD-V。 QEMU\r安裝 KVM Determine the if Hardware virtualization is Enabled or not. # grep -E '(vmx|svm)' /proc/cpuinfo or # egrep \"vmx|svm\" /proc/cpuinfo kvm需要安裝qemu-kvm、libvirt，kvm就不用說明了，libvirt是做虛擬機管理用的。 使用指令建立虛擬機的優點就是可以選擇建立的各個參數，例如磁碟鏡像使用raw聽說是相對而言最快的，但是virt-manager卻只可以建立建立qcow2，當然格式這些可以互相轉換。 $ sudo apt-get install qemu-kvm libvirt-bin virtinst $ systemctl enable libvirtd $ systemctl start libvirtd $ ## 建立10GB的虛擬硬碟 qemu-img create -f qcow2 /var/lib/libvirt/images/ubuntu_vm1.qcow2 10G qemu-img info ubuntu_vm1.qcow2 ## 用virtinst 安裝 （預設vnc port=5900） $ virt-install --virt-type kvm --name ubuntu_vm1 --ram 1024 \\ --cdrom=/opt/ubuntu-18.04.1-desktop-amd64.iso \\ --disk /var/lib/libvirt/images/ubuntu_vm1.qcow2,format=qcow2,format=qcow2,size=10,sparse=true|false \\ --network network=default \\ --graphics vnc,listen=0.0.0.0 --noautoconsole \\ --os-type=linux --os-variant=ubuntutrusty WARNING No operating system detected, VM performance may suffer. Specify an OS with --os-variant for optimal results. ERROR Couldn't create storage volume 'ubuntu_vm1.qcow2': '[Errno 32] Broken pipe' Domain installation does not appear to have been successful. If it was, you can restart your domain by running: virsh --connect qemu:///system start ubuntu_vm1 ## 重新執行一次 $ virsh --connect qemu:///system start ubuntu_vm1 $ virt-install --virt-type kvm --name ubuntu_vm1 --ram 1024 \\ --cdrom=/opt/ubuntu-18.04.1-desktop-amd64.iso \\ --disk /var/lib/libvirt/images/ubuntu_vm1.qcow2,format=qcow2,format=qcow2,size=10,sparse=true|false \\ --network network=default \\ --graphics vnc,listen=0.0.0.0 --noautoconsole \\ --os-type=linux --os-variant=ubuntutrusty ## 格式轉換 ： qcow2 , qed , raw , vdi , vpc , vmdk ## The qcow2 type can be created if the qemu-img tool is present. The others are dependent on support of the qemu-img tool. # example kvm -\u003e vmware $ qemu-img convert -f raw -O vmdk -p windows.raw /run/media/geek/2TB/Virtual\\ Machines/Windows/windows.vmdk $ vmkfstools -i windows.vmdk -d thin windows_transfered.vmdk Install\r在經過折騰一陣之後我發現直接用virt-manager安裝就行了，指令安裝可能有它的好處在吧！ $ sudo apt-get install qemu-kvm libvirt-bin virtinst virt-manager $ systemctl enable libvirtd $ systemctl start libvirtd $ virt-manager # 圖形界面 Install\r","date":"2018-10-30","objectID":"/2018-10-30/:1:0","tags":["vm","kvm","libvirt","qemu"],"title":"KVM安裝","uri":"/2018-10-30/"},{"categories":null,"content":"vnc server 安裝vnc server，並且啟動vncserver，可以在遠端透過vnc遙控vm主機 $ sudo apt install xfce4 xfce4-goodies $ sudo apt install tightvncserver $ vncserver You will require a password to access your desktops. Password: Verify: Would you like to enter a view-only password (y/n)? y Password: Verify: New 'X' desktop is geek-virtual-machine:1 Creating default startup script /home/geek/.vnc/xstartup Starting applications specified in /home/geek/.vnc/xstartup Log file is /home/geek/.vnc/geek-virtual-machine:1.log ","date":"2018-10-30","objectID":"/2018-10-30/:2:0","tags":["vm","kvm","libvirt","qemu"],"title":"KVM安裝","uri":"/2018-10-30/"},{"categories":null,"content":"virsh list 查看/啟動/刪除 kvm $ virsh list --all Id Name State ---------------------------------------------------- - ubuntu_vm1 shut off $ virsh start ubuntu_vm1 Domain ubuntu_vm1 started ## 如果要刪除 KVM $ virsh undefine ubuntu_vm1 --remove-all-storage Domain ubuntu_vm1 has been undefined Volume 'hda'(/opt/ubuntu_vm1.qcow2) removed. ## 遠端連線範例 $ virsh --connect qemu+ssh://geek@192.168.59.129/system list --all ","date":"2018-10-30","objectID":"/2018-10-30/:3:0","tags":["vm","kvm","libvirt","qemu"],"title":"KVM安裝","uri":"/2018-10-30/"},{"categories":null,"content":"虛擬機管理 libvirt管理虛擬機有一個很大的優點，就是在管理的過程中，如果libvirt不動作了，不會影響到KVM，他們沒有依賴關係。 $ pwd /etc/libvirt/qemu $ ll total 12K drwxr-xr-x 3 root root 4.0K Oct 31 23:01 networks -rw------- 1 root root 4.1K Nov 1 20:22 ubuntu_vm1.xml \u003c!-- WARNING: THIS IS AN AUTO-GENERATED FILE. CHANGES TO IT ARE LIKELY TO BE OVERWRITTEN AND LOST. Changes to this xml configuration should be made using: virsh edit ubuntu_vm1 or other application using the libvirt API. --\u003e \u003cdomain type='kvm'\u003e \u003cname\u003eubuntu_vm1\u003c/name\u003e \u003cuuid\u003eeb6f6313-ba45-4255-8df3-89773ef183b4\u003c/uuid\u003e \u003cmemory unit='KiB'\u003e1048576\u003c/memory\u003e . . . 在etc目錄下面libvirt個設定檔案，告訴我們說他的設定是自動生成的，要我們自行去用指令做設定。 ip addr del dev eth0 192.168.56.32/24 ","date":"2018-10-30","objectID":"/2018-10-30/:4:0","tags":["vm","kvm","libvirt","qemu"],"title":"KVM安裝","uri":"/2018-10-30/"},{"categories":null,"content":"虛擬機網路管理 libvert networking 可以使用Linux Virtual Networking的virtual network switch來達到layer2使用TAP指令、layer3 使用TUN(tunnel) 指令。 …..To be continue ","date":"2018-10-30","objectID":"/2018-10-30/:5:0","tags":["vm","kvm","libvirt","qemu"],"title":"KVM安裝","uri":"/2018-10-30/"},{"categories":null,"content":"Hugo 和 LoveIt 中的 Emoji 的用法指南.","date":"2017-05-04","objectID":"/2017-05-04/","tags":["gource","ffmpeg"],"title":"Gource — GitHub Log Visualization","uri":"/2017-05-04/"},{"categories":null,"content":" 我一直很想試試看Gource這個玩意，但是之前一直沒有在使用GitHub，所以也沒有辦法玩，最近不知道為什麼突然使用過\u003c(￣︶￣)↗[GO!]，所以就想要玩玩看這個東西，就結果而言，我是做出來了，HaHa！！ ","date":"2017-05-04","objectID":"/2017-05-04/:0:0","tags":["gource","ffmpeg"],"title":"Gource — GitHub Log Visualization","uri":"/2017-05-04/"},{"categories":null,"content":"安裝項目 在這個過程中因為需要使用到Gource、ffmpeg，所以第一步就是安裝這兩個東西，還好Homebrew很強大可以直接用來安裝，不然我又要看一下資料了。 brew update brew install ffmpeg brew install gource ","date":"2017-05-04","objectID":"/2017-05-04/:1:0","tags":["gource","ffmpeg"],"title":"Gource — GitHub Log Visualization","uri":"/2017-05-04/"},{"categories":null,"content":"使用的目錄 安裝完之後，我cd（change directory）到我的repo下面執行gource的命令行，但是它卻給我報這個訊息： cd myrepo_pwd gource fatal: your current branch 'master' does not have any commits yet gource: failed to generate log file Try 'gource --help' for more information. 經過一番的研究我發現可能是因為我使用的Hexo Depoly的命令行在執行的時候，會將我的檔案複製到另外一個資料夾才進行檔案提交的三個指令。 git add --all git commit -m \"Initial commit\" git push -u origin master 所以我去查了一下hexo-deployer-git的說明，發現下面有一段話： How it works hexo-deployer-git works by generating the site in .deploy_git and force pushing to the repo(es) in config. If .deploy_git does not exist, a repo will initialized (git init). Otherwise the curent repo (with its commit history) will be used. Users can clone the deployed repo to .deploy_git to keep the \u003ecommit history. git clone .deploy_git hexo g -d 所以我認為上面的指令是把檔案轉換（hexo g)，在丟到public目錄，再複製到個叫做.deploy_git的隱藏資料夾進行檔案提交的，所以我的.git log一定就在這裡。 gource\rgource --hide dirnames,filenames --seconds-per-day 0.1 --auto-skip-seconds 1 -1280x720 -o - | ffmpeg -y -r 60 -f image2pipe -vcodec ppm -i - -vcodec libx264 -preset ultrafast -pix_fmt yuv420p -crf 1 -threads 0 -bf 0 pwd_gource.mp4 gource\r","date":"2017-05-04","objectID":"/2017-05-04/:2:0","tags":["gource","ffmpeg"],"title":"Gource — GitHub Log Visualization","uri":"/2017-05-04/"},{"categories":["Linux"],"content":"Hugo 和 LoveIt 中的 Emoji 的用法指南.","date":"2017-04-27","objectID":"/2017_04_27_3/","tags":["Linux筆記"],"title":"Linux 幫助指令","uri":"/2017_04_27_3/"},{"categories":["Linux"],"content":"Linux 查找命令的用法的時候可以使用Linux下面的幫助指令查找命令的使用方法。 ","date":"2017-04-27","objectID":"/2017_04_27_3/:0:0","tags":["Linux筆記"],"title":"Linux 幫助指令","uri":"/2017_04_27_3/"},{"categories":["Linux"],"content":"man 使用 $ man ls 文檔內容 LS(1) NAME ls - list directory contents SYNOPSIS ls [OPTION]... [FILE]... DESCRIPTION List information about the FILEs (the current directory by default). Sort entries alphabetically if none of -cftuvSUX nor --sort is spec‐ ified. Mandatory arguments to long options are mandatory for short options too. -a, --all do not ignore entries starting with . -A, --almost-all do not list implied . and .. --author with -l, print the author of each file -b, --escape print C-style escapes for nongraphic characters --block-size=SIZE scale sizes by SIZE before printing them; e.g., '--block-size=M' prints sizes in units of 1,048,576 bytes; see SIZE format below -B, --ignore-backups do not list implied entries ending with ~ -c with -lt: sort by, and show, ctime (time of last modification of file status information); with -l: show ctime and sort by Manual page ls(1) line 1 (press h for help or q to quit) 輸入之後會會看到ls指令的相關用法如上，輸入之後可以開始查找文檔裡面的內容了，進入man模式之後其實它的操作跟vi的操作十分雷同。 如果要離開的話只要輸入一個q就可以離開了，同vi的操作如果我要查找-d的使用方式，我只要打入/-d，他就會跳到第一個出現-d的位置了，如果是要找前、後一個-d，只要輸入n、shift+n。 ","date":"2017-04-27","objectID":"/2017_04_27_3/:1:0","tags":["Linux筆記"],"title":"Linux 幫助指令","uri":"/2017_04_27_3/"},{"categories":["Linux"],"content":"man 文件級別 在之前輸入man ls的時候，有告知LS(1)，這個級別1代表指令的用戶級別，各個查找級別如下： $ man man 用戶級別 . . . The table below shows the section numbers of the manual followed by the types of pages they contain. 1 Executable programs or shell commands 2 System calls (functions provided by the kernel) 3 Library calls (functions within program libraries) 4 Special files (usually found in /dev) 5 File formats and conventions eg /etc/passwd 6 Games 7 Miscellaneous (including macro packages and conventions), e.g. man(7), groff(7) 8 System administration commands (usually only for root) 9 Kernel routines [Non standard] 級別 查找內容 1 命令 2 內核調用函數 3 函數與數據庫 4 特殊文件（/dev下的文件） 5 配置文件（/etc下的文件） 6 遊戲 7 其他雜項 8 系統管理員可用命令 9 內核相關文件 ","date":"2017-04-27","objectID":"/2017_04_27_3/:1:1","tags":["Linux筆記"],"title":"Linux 幫助指令","uri":"/2017_04_27_3/"},{"categories":["Linux"],"content":"man -f or whatis 綜上所述，我們查找的ls是屬於命令的級別，級別為1。如果我們要查找指令的級別的話使用-f或是whatis如下： $ man -f passwd $ whatis passwd 輸出 passwd (1) - update user's authentication tokens passwd (5) - password file sslpasswd (1ssl) - compute password hashes 上面我們查找passwd有兩個級別（只查得到有安裝的幫助文檔），但是我們使用man passwd，出現的是級別1的內容，因為預設是打開等級最小的文件內容，所以如果要看級別5的內容，要輸入如下： $ man 5 passwd 透過這樣的查詢，我們就可以查找到我們想要的訊息了。 之後我們發現級別5是配置文件，如果我們要找它的位置只要輸入如下： $ whereis passwd passwd: /usr/bin/passwd /etc/passwd /usr/share/man/man1/passwd.1.gz /usr/share/man/man5/passwd.5.gz 其他級別的指令 $ whatis ifconfig ifconfig (8) - configure a network interface $ whatis netstat netstat(1) - show network status $ whatis null BIO_f_null(3ssl) - null filter BIO_s_null(3ssl) - null data sink DBD::Gofer::Transport::null(3pm) - DBD::Gofer client transport for testing DBM_Filter::null(3pm) - filter for DBM_Filter Net::DNS::RR::NULL(3pm) - DNS NULL resource record PPI::Statement::Null(3pm) - A useless null statement null(4) - the null device null(n) - Create and manipulate null channels openpam_nullconv(3) - null conversation function slapd-null(5) - Null backend to slapd uuid_clear(3) - reset value of UUID variable to the NULL value uuid_is_null(3) - compare the value of the UUID to the NULL value ","date":"2017-04-27","objectID":"/2017_04_27_3/:1:2","tags":["Linux筆記"],"title":"Linux 幫助指令","uri":"/2017_04_27_3/"},{"categories":["Linux"],"content":"man -k or apropos 查找所有相關指令幫助 $ man -k passwd $ apropos passwd CURLOPT_KEYPASSWD(3) - set passphrase to private key SSL_CTX_set_default_passwd_cb(3ssl), SSL_CTX_set_default_passwd_cb_userdata(3ssl) - set passwd callback for encrypted PEM file handling chkpasswd(8) - verifies user password against various systems firmwarepasswd(8) - tool for setting and removing firmware passwords on a system htpasswd(1) - Manage user files for basic authentication kpasswd(1) - Kerberos 5 password changing program kpasswdd(8) - Kerberos 5 password changing server ldappasswd(1) - change the password of an LDAP entry passwd(1) - modify a user's password passwd(1ssl) - compute password hashes passwd(5), master.passwd(5) - format of the password file slapd-passwd(5) - /etc/passwd backend to slapd slappasswd(8) - OpenLDAP password utility 如果我們是要找htpasswd的幫助文檔，但卻忘了指令的名稱，只記得有passwd這個字的時候，可以使用man -k或apropos來查找指令，這個指令會列出所有相關的文檔。 ","date":"2017-04-27","objectID":"/2017_04_27_3/:1:3","tags":["Linux筆記"],"title":"Linux 幫助指令","uri":"/2017_04_27_3/"},{"categories":["Linux"],"content":"其他指令 查找指令的內容還可以使用info、help可以使用，而查找指令別名或位置還有whereis、which、type -a、command -v、command -V、alias可以使用 ","date":"2017-04-27","objectID":"/2017_04_27_3/:2:0","tags":["Linux筆記"],"title":"Linux 幫助指令","uri":"/2017_04_27_3/"},{"categories":["Linux"],"content":"help 和 info help只能夠查詢shell自帶的命令內容 $ help cd info的操作上比較複雜，雖然比較詳細，但是使用上比較複雜而且還有很多要記得一些用法。 Enter 進入子頁面（在*的地方按） u 回到上一個頁面 n 進入下一個小節 p 進入上一個小節 q 離開 $ info ls 輸出 10.1 'ls': List directory contents ================================== The 'ls' program lists information about files (of any type, including ............ * Menu: * ls invocation:: List directory contents. * dir invocation:: Briefly ls. * vdir invocation:: Verbosely ls. * dircolors invocation:: Color setup for ls, etc . . . 在這裡按下u、n會進入下一個、上一個小節，如上如果按下u會變成10.2的章節，反之n則會回到10.1，離開info按q。 文檔裡面看到*的時候可以按下Enter進入別的頁面，返回則按u。 ","date":"2017-04-27","objectID":"/2017_04_27_3/:2:1","tags":["Linux筆記"],"title":"Linux 幫助指令","uri":"/2017_04_27_3/"},{"categories":["Linux"],"content":"whereis、which、type -a、command -v、command -V $ whereis cd ##查找位置 /usr/bin/cd $ which cd ##查找shell自帶指令是會顯示 cd: shell built-in command $ which ll ##查找別名指令的指令名稱 ll: aliased to ls -lh 使用whereis我們可以查找指令的位置，which則可以查詢別名指令的全名以及是否為shell自帶的指令 type -a 更方便 $ type -a cd cd is a shell builtin cd is /usr/bin/cd $ type -a ll ll is an alias for ls -lh type -a和whereis\u0026which比較起來方便了許多，type -a和其他兩個指令不一樣的是，其他兩個指令是搜索$PATH找到的，而type -a是自己去執行一次的到的，就操作而言type -a簡單了不少，一個指令就可以查詢了。 command -v or -V $ command -v cd cd $ command -V cd cd is a shell builtin $ command -v ll alias ll='ls -lh' $ command -V ll ll is an alias for ls -lh 另外還有command -v or -V也可以用來查詢，它一樣是搜索$PATH找到內容的，優點是比較好記。 ","date":"2017-04-27","objectID":"/2017_04_27_3/:2:2","tags":["Linux筆記"],"title":"Linux 幫助指令","uri":"/2017_04_27_3/"},{"categories":["Linux"],"content":"Hugo 和 LoveIt 中的 Emoji 的用法指南.","date":"2017-04-27","objectID":"/2017_04_27_2/","tags":["Linux筆記"],"title":"Linux 壓縮與解壓縮","uri":"/2017_04_27_2/"},{"categories":["Linux"],"content":"檔案壓縮有很多種方式，所以也有很多的壓縮格式，各種壓縮方式也有它的優缺點，當然這不是這篇的重點，這篇主要是要說在Linux上面壓縮與解壓縮的方式。 在Linux上面其中壓縮格式比較常見的有.zip、.gz、.bz2、.tar.gz、.tar.bz2 在壓縮的過程中，其實可以不用把副檔名寫上去，因為Linux是不會認這個東西的，但是為了方便辨認大部分操作上，還是要寫上去才可以。 ","date":"2017-04-27","objectID":"/2017_04_27_2/:0:0","tags":["Linux筆記"],"title":"Linux 壓縮與解壓縮","uri":"/2017_04_27_2/"},{"categories":["Linux"],"content":"zip 壓縮 *.zip zip [option] [filename] [source file] zip -r [filename] [source file] $ touch myfile $ zip myfile.zip myfile adding: myfile (stored 0%) ## 因為myfile是空文件所以為0% $ mkdir myfiles $ mv myfile myfiles $ zip myfile.zip myfile/ ## 只有壓縮目錄，解壓縮為空目錄 adding: myfile/ (stored 0%) $ zip -r myfile.zip myfile/ ## 只有壓縮目錄及目錄下的檔案 updating: myfile/ (stored 0%) adding: myfile/asdf (stored 0%） ","date":"2017-04-27","objectID":"/2017_04_27_2/:1:0","tags":["Linux筆記"],"title":"Linux 壓縮與解壓縮","uri":"/2017_04_27_2/"},{"categories":["Linux"],"content":"unzip 解壓縮 $ unzip myfile.zip Archive: myfile.zip creating: myfile/ extracting: myfile/myfile ","date":"2017-04-27","objectID":"/2017_04_27_2/:2:0","tags":["Linux筆記"],"title":"Linux 壓縮與解壓縮","uri":"/2017_04_27_2/"},{"categories":["Linux"],"content":"gzip 壓縮 *.gz gzip [source file] $ touch myfile $ gzip myfile $ ll 總計 8 drwxr-xr-x. 15 root root 4096 4月 4 19:56 DIR-850L_A1 -rw-rw-r--. 1 cyberjun cyberjun 27 4月 26 19:29 myfile.gz gzip -c [source file] \u003e [filename] $ touch myfile $ gzip -c myfile \u003e myfile.gz $ ll 總計 8 drwxr-xr-x. 15 root root 4096 4月 4 19:56 DIR-850L_A1 -rw-rw-r--. 1 cyberjun cyberjun 0 4月 26 19:32 myfile -rw-rw-r--. 1 cyberjun cyberjun 27 4月 26 19:32 myfile.gz gzip在壓縮之後原本的文件會消失，所以我們要把命令的結果寫到新的文件儲存，也就是使用\u003e把結果給[filename]。 gzip -r [directory] $ mkdir myfiles $ cd myfiles $ touch myfile1 $ touch myfile2 $ touch myfile3 $ cd .. $ gzip -r myfiles $ ll 總計 4 drwxr-xr-x. 15 root root 4096 4月 4 19:56 DIR-850L_A1 drwxrwxr-x. 2 cyberjun cyberjun 60 4月 26 19:35 myfiles $ cd myfiles $ ll 總計 12 -rw-rw-r--. 1 cyberjun cyberjun 28 4月 26 19:34 myfile1.gz -rw-rw-r--. 1 cyberjun cyberjun 28 4月 26 19:34 myfile2.gz -rw-rw-r--. 1 cyberjun cyberjun 28 4月 26 19:34 myfile3.gz 執行完這個指令之後他會把目錄下面的所有文件一個一個壓縮，但是不會把目錄給壓縮。 ","date":"2017-04-27","objectID":"/2017_04_27_2/:3:0","tags":["Linux筆記"],"title":"Linux 壓縮與解壓縮","uri":"/2017_04_27_2/"},{"categories":["Linux"],"content":"gzip -d或gunzip解壓縮 *.gz $ gzip -d myfile.gz $ gunzip myfile.gz $ gunzip myfiles.gz $ cd myfiles $ ll 總計 12 -rw-rw-r--. 1 cyberjun cyberjun 28 4月 26 19:34 myfile1.gz -rw-rw-r--. 1 cyberjun cyberjun 28 4月 26 19:34 myfile2.gz -rw-rw-r--. 1 cyberjun cyberjun 28 4月 26 19:34 myfile3.gz $ cd .. $ gunzip -r myfiles gzip: myfiles is a directory -- ignored ## 目錄要 -r $ gunzip -r myfiles $ ll 總計 4 drwxr-xr-x. 15 root root 4096 4月 4 19:56 DIR-850L_A1 drwxrwxr-x. 2 cyberjun cyberjun 51 4月 26 19:42 myfiles $ cd myfiles/ $ ll 總計 0 -rw-rw-r--. 1 cyberjun cyberjun 0 4月 26 19:34 myfile1 -rw-rw-r--. 1 cyberjun cyberjun 0 4月 26 19:34 myfile2 -rw-rw-r--. 1 cyberjun cyberjun 0 4月 26 19:34 myfile3 ","date":"2017-04-27","objectID":"/2017_04_27_2/:4:0","tags":["Linux筆記"],"title":"Linux 壓縮與解壓縮","uri":"/2017_04_27_2/"},{"categories":["Linux"],"content":"bzip2 壓縮 *.bz2 bzip2 [sourcefile] $ touch abc $ bzip2 abc $ ll 總計 4 -rw-rw-r--. 1 cyberjun cyberjun 14 4月 26 19:49 abc.bz2 這個樣子原本的文件會和gzip一樣消失，如果要保留原本的文件要使用-k。 bzip2 -k [sourcefile] $ touch -k abc $ bzip2 abc $ ll 總計 8 -rw-rw-r--. 1 cyberjun cyberjun 0 4月 26 19:52 abc -rw-rw-r--. 1 cyberjun cyberjun 14 4月 26 19:52 abc.bz2 使用-k這個樣子原本的文件保留下來了。 bzip2不能壓縮目錄 $ mkdir abc $ bzip2 abc bzip2: Input file abc is a directory. bzip2並沒有支援目錄壓縮 ","date":"2017-04-27","objectID":"/2017_04_27_2/:5:0","tags":["Linux筆記"],"title":"Linux 壓縮與解壓縮","uri":"/2017_04_27_2/"},{"categories":["Linux"],"content":"bzip2 -d或bunzip2解壓縮 *.bz2 $ touch abc $ bzip2 abc $ bzip2 -d abc.bz2 $ ll abc.bz2 $ rm -rf ab* $ touch abc $ bzip2 abc $ bunzip2 abc.bz2 $ ls abc.bz2 解壓縮執行之後原本的檔案會消失，所以如果要保留原本的檔案要使用-k $ bunzip -k abc.bz2 $ bzip -dk abc.bz2 tar 打包 由於gzip和bzip2不能把目錄壓縮起來所以就有了tar了打包，如果要壓縮的話就只要把檔案先打包起來再壓縮成.tar.gz、.tar.bz2就可以了 ","date":"2017-04-27","objectID":"/2017_04_27_2/:6:0","tags":["Linux筆記"],"title":"Linux 壓縮與解壓縮","uri":"/2017_04_27_2/"},{"categories":["Linux"],"content":"tar -cvf 打包 *.tar tar -cvf [filename] [sourcefile] -c: 打包 -v: 顯示打包過程 -f: 指定打包後的文件名稱 $ mkdir myfiles $ cd myfiles/ $ touch myfile1 $ touch myfile2 $ touch myfile $ cd .. $ tar -cvf myfiles.tar myfiles myfiles/ myfiles/myfile1 myfiles/myfile2 myfiles/myfile $ ll 總計 16 drwxrwxr-x. 2 cyberjun cyberjun 50 4月 26 20:14 myfiles -rw-rw-r--. 1 cyberjun cyberjun 10240 4月 26 20:14 myfiles.tar 之後如果想要在進行gzip、bzip2壓縮的話，就直接執行壓縮如下： $ gzip -c myfiles.tar \u003e $ bzip2 -k myfiles.tar $ ll 總計 24 drwxrwxr-x. 2 cyberjun cyberjun 50 4月 26 20:14 myfiles -rw-rw-r--. 1 cyberjun cyberjun 10240 4月 26 20:14 myfiles.tar -rw-rw-r--. 1 cyberjun cyberjun 191 4月 26 20:14 myfiles.tar.bz2 -rw-rw-r--. 1 cyberjun cyberjun 191 4月 26 20:18 myfiles.tar.gz ","date":"2017-04-27","objectID":"/2017_04_27_2/:7:0","tags":["Linux筆記"],"title":"Linux 壓縮與解壓縮","uri":"/2017_04_27_2/"},{"categories":["Linux"],"content":"tar -xvf 解打包 tar -xvf [.tar file] -x 解打包 解.tar.gz $ gunzip -c myfiles.tar.gz \u003e myfiles.tar $ tar -xvf myfiles.tar myfiles/ myfiles/myfile1 myfiles/myfile2 myfiles/myfile $ ll 總計 24 drwxrwxr-x. 2 cyberjun cyberjun 50 4月 26 20:14 myfiles -rw-rw-r--. 1 cyberjun cyberjun 10240 4月 26 20:31 myfiles.tar -rw-rw-r--. 1 cyberjun cyberjun 191 4月 26 20:27 myfiles.tar.gz 解.tar.bz2 $ bunzip -k myfiles.tar.bz2 $ tar -xvf myfiles.tar $ ll 總計 24 drwxrwxr-x. 2 cyberjun cyberjun 50 4月 26 20:14 myfiles -rw-rw-r--. 1 cyberjun cyberjun 10240 4月 26 20:28 myfiles.tar -rw-rw-r--. 1 cyberjun cyberjun 191 4月 26 20:14 myfiles.tar.bz2 打包.tar.gz和.tar.bz2 tar是支援直接打包成.tar.gz、.tar.bz2的，所以其實不需要像之前那個樣子壓縮與解壓縮這麼麻煩。 ","date":"2017-04-27","objectID":"/2017_04_27_2/:8:0","tags":["Linux筆記"],"title":"Linux 壓縮與解壓縮","uri":"/2017_04_27_2/"},{"categories":["Linux"],"content":"tar -z cvf或xvf tar -zcvf [filename.tar.gz] [sourcefile] tar -zxvf [sourcefile.tar.gz] 如果要打包成.tar.gz的話，只要在之前的打包指令前面加上-z即可。 $ tar -zcvf myfiles.tar.gz myfiles/ myfiles/ myfiles/myfile1 myfiles/myfile2 myfiles/myfile $ rm -rf myfiles $ tar -zxvf myfiles.tar.gz myfiles/ myfiles/myfile1 myfiles/myfile2 myfiles/myfile $ ll 總計 8 drwxrwxr-x. 2 cyberjun cyberjun 50 4月 26 20:14 myfiles -rw-rw-r--. 1 cyberjun cyberjun 179 4月 26 20:46 myfiles.tar.gz ","date":"2017-04-27","objectID":"/2017_04_27_2/:9:0","tags":["Linux筆記"],"title":"Linux 壓縮與解壓縮","uri":"/2017_04_27_2/"},{"categories":["Linux"],"content":"tar -j cvf 或xvf tar -jcvf [filename.tar.bz2] [sourcefile] tar -jxvf [sourcefile.tar.bz2] 如果要打包成.tar.bz2的話，只要在之前的打包指令前面加上-j即可。 $ tar -jcvf myfiles.tar.bz2 myfiles/ myfiles/ myfiles/myfile1 myfiles/myfile2 myfiles/myfile $ rm -rf myfiles $ tar -jxvf myfiles.tar.bz2 myfiles/ myfiles/myfile1 myfiles/myfile2 myfiles/myfile $ ll 總計 8 drwxrwxr-x. 2 cyberjun cyberjun 50 4月 26 20:14 myfiles -rw-rw-r--. 1 cyberjun cyberjun 191 4月 26 20:48 myfiles.tar.bz2 ","date":"2017-04-27","objectID":"/2017_04_27_2/:10:0","tags":["Linux筆記"],"title":"Linux 壓縮與解壓縮","uri":"/2017_04_27_2/"},{"categories":["Linux"],"content":"tar 指定解壓縮位置 tar -xvf [sourcefile.tar] -C [directory] $ tar -zcvf myfiles.tar.gz myfiles/ myfiles/ myfiles/myfile1 myfiles/myfile2 myfiles/myfile $ tar -zxvf myfiles.tar.gz -C /tmp/ $ ll /tmp/ 總計 8 drwxrwxr-x. 2 cyberjun cyberjun 50 4月 26 20:14 myfiles drwx------. 3 root root 17 4月 26 14:45 systemd-private-14d94e1345584cf1b22f365c4e00445b-vmtoolsd.service-6dKW4n #@ tar 壓縮多個文件 tar -cvf [filename.tar] [file1] [file2]….etc. 如果要指定壓縮位置的話，只要把[filename.tar]用絕對路徑去寫就可以了。 $ ll 總計 8 -rw-rw-r--. 1 cyberjun cyberjun 0 4月 26 20:14 myfile -rw-rw-r--. 1 cyberjun cyberjun 0 4月 26 20:13 myfile1 -rw-rw-r--. 1 cyberjun cyberjun 0 4月 26 20:14 myfile2 -rw-rw-r--. 1 cyberjun cyberjun 142 4月 26 21:01 myfile3.tar.bz2 -rw-rw-r--. 1 cyberjun cyberjun 139 4月 26 21:01 myfile3.tar.gz drwxrwxr-x. 2 cyberjun cyberjun 6 4月 26 20:59 myfiledir $ tar -cvf ~/myfiles.tar myfile myfile1 myfile2 myfile3.tar.bz2 myfile3.tar.gz myfile myfile1 myfile2 myfile3.tar.bz2 myfile3.tar.gz $ cd $ ll 總計 16 -rw-rw-r--. 1 cyberjun cyberjun 10240 4月 26 21:02 myfiles.tar ","date":"2017-04-27","objectID":"/2017_04_27_2/:11:0","tags":["Linux筆記"],"title":"Linux 壓縮與解壓縮","uri":"/2017_04_27_2/"},{"categories":["Linux"],"content":"Hugo 和 LoveIt 中的 Emoji 的用法指南.","date":"2017-04-27","objectID":"/2017_04_27/","tags":["Linux筆記"],"title":"Linux 掛載命令","uri":"/2017_04_27/"},{"categories":["Linux"],"content":"mount 查看已經掛載的設備 在Linux上面要使用一些設備需要自己掛載，比如光碟機之類的，就需要使用掛載命令把它掛載到/mnt下面 # mount sysfs on /sys type sysfs (rw,nosuid,nodev,noexec,relatime,seclabel) proc on /proc type proc (rw,nosuid,nodev,noexec,relatime) devtmpfs on /dev type devtmpfs (rw,nosuid,seclabel,size=231216k,nr_inodes=57804,mode=755) . . . /dev/sda1 on /boot type xfs (rw,relatime,seclabel,attr2,inode64,noquota) tmpfs on /run/user/1000 type tmpfs (rw,nosuid,nodev,relatime,seclabel,size=48388k,mode=700,uid=1000,gid=1000) ","date":"2017-04-27","objectID":"/2017_04_27/:1:0","tags":["Linux筆記"],"title":"Linux 掛載命令","uri":"/2017_04_27/"},{"categories":["Linux"],"content":"mount -a 自動掛載 上面查詢了系統掛載的文件，其中我們要操作的一般只有sda的地方，並不會動到/proc、/sys這些內存記憶體的檔案（沒有持有者） # mount -a # cat /etc/fstab # # /etc/fstab # Created by anaconda on Sun Mar 26 00:04:18 2017 # # Accessible filesystems, by reference, are maintained under '/dev/disk' # See man pages fstab(5), findfs(8), mount(8) and/or blkid(8) for more info # /dev/mapper/cl-root / xfs defaults 0 0 UUID=1920c627-4c4a-4ce9-a089-ea5e113f1eca /boot UUID=daf56b8e-477c-7qj0-jikb-5e15eaca3f1e /home xfs defaults 0 0 /dev/mapper/cl-swap swap swap defaults 0 0 自動掛載是依據/etc/fstab這個設定檔的內容進行掛載，這個設定檔案裡面的內容會在開機的時候自動掛載，如果有/proc、/sys的話最好不要動。 自動掛載不要把隨身碟和光碟機也放進去，如果開機沒有讀取到這些設備，很可能會進不去系統。 ","date":"2017-04-27","objectID":"/2017_04_27/:2:0","tags":["Linux筆記"],"title":"Linux 掛載命令","uri":"/2017_04_27/"},{"categories":["Linux"],"content":"掛載方式 mount [-t vfstype] [-o optlist] [device name] [mount position] option: -t 文件系統（ext3、ext4、iso9660…etc） -o 特殊選項 [root@localhost cyberjun]# ./myshell.sh bash: ./myshell.sh: 拒絕不符權限的操作 [root@localhost cyberjun]# chmod 755 myshell.sh [root@localhost cyberjun]# chown cyberjun:cyberjun myshell.sh [root@localhost cyberjun]# ./myshell.sh My shell work fine [root@localhost cyberjun]# ","date":"2017-04-27","objectID":"/2017_04_27/:3:0","tags":["Linux筆記"],"title":"Linux 掛載命令","uri":"/2017_04_27/"},{"categories":["Linux"],"content":"Hugo 和 LoveIt 中的 Emoji 的用法指南.","date":"2017-04-26","objectID":"/2017_04_26/","tags":["Linux筆記"],"title":"Linux關機命令","uri":"/2017_04_26/"},{"categories":["Linux"],"content":"shutdown shutdown [option] [time] option: -c 取消關機命令 -h 關機 -r 重新開機 $ shutdown now $ shutdown -r now [cyberjun@localhost ~]$ shutdown -r 05:30 Must be root. [cyberjun@localhost ~]$ su 密碼： [root@localhost cyberjun]# shutdown -r 05:30 Shutdown scheduled for 五 2017-04-28 05:30:00 CST, use 'shutdown -c' to cancel. [root@localhost cyberjun]# shutdown -c Broadcast message from root@localhost.localdomain (Thu 2017-04-27 17:21:20 CST): The system shutdown has been cancelled at Thu 2017-04-27 17:22:20 CST! shutdown的關機比較安全，如果可以的話還是使用shutdown來關機，如果有打開一些伺服器、網路接口之類的就必須先關掉在關機會比較安全。 ","date":"2017-04-26","objectID":"/2017_04_26/:1:0","tags":["Linux筆記"],"title":"Linux關機命令","uri":"/2017_04_26/"},{"categories":["Linux"],"content":"half、poweroff、init 0 # halt # poweroff # init 0 直接關機，這三個指令和shutdown比起來爛了不少，如果可以用shutdown就用shutdown，上面三個指令執行會有一些資料沒有貯存。 ","date":"2017-04-26","objectID":"/2017_04_26/:2:0","tags":["Linux筆記"],"title":"Linux關機命令","uri":"/2017_04_26/"},{"categories":["Linux"],"content":"其他重啟命令 # reboot # init 6 ","date":"2017-04-26","objectID":"/2017_04_26/:3:0","tags":["Linux筆記"],"title":"Linux關機命令","uri":"/2017_04_26/"},{"categories":["Linux"],"content":"init 運行級別 $ man init 其中內容 SIGHUP Reloads the complete daemon configuration. This is mostly equivalent to systemctl daemon-reload. SIGRTMIN+0 Enters default mode, starts the default.target unit. This is mostly equivalent to systemctl start default.target. SIGRTMIN+1 Enters rescue mode, starts the rescue.target unit. This is mostly equivalent to systemctl isolate rescue.target. SIGRTMIN+2 Enters emergency mode, starts the emergency.service unit. This is mostly equivalent to systemctl isolate emergency.service. SIGRTMIN+3 Halts the machine, starts the halt.target unit. This is mostly equivalent to systemctl start halt.target. SIGRTMIN+4 Powers off the machine, starts the poweroff.target unit. This is mostly equivalent to systemctl start poweroff.target. SIGRTMIN+5 Reboots the machine, starts the reboot.target unit. This is mostly equivalent to systemctl start reboot.target. SIGRTMIN+6 Reboots the machine via kexec, starts the kexec.target unit. This is mostly equivalent to systemctl start kexec.target. . . . 級別 動作 0 關機 1 救援模式 3 進入文字界面 5 進入GUI模式 6 重新開機 如果要查詢現在界面所在的級別可以執行runlevel；注意！我是使用CentOS來舉例，如果是Debian的系統就不一樣了，要自己去用man查詢。 $ runlevel N 3 ##在文字界面 如果要設定開機之後進入的級別可以找/etc/inittab文件看一下，其中級別0和級別6，是不能設定在裡面的，如果設定了，初學者大概只有重新安裝這個辦法了。 $ cat /etc/inittab # inittab is no longer used when using systemd. # # ADDING CONFIGURATION HERE WILL HAVE NO EFFECT ON YOUR SYSTEM. # # Ctrl-Alt-Delete is handled by /usr/lib/systemd/system/ctrl-alt-del.target # # systemd uses 'targets' instead of runlevels. By default, there are two main targets: # # multi-user.target: analogous to runlevel 3 # graphical.target: analogous to runlevel 5 # # To view current default target, run: # systemctl get-default # # To set a default target, run: # systemctl set-default TARGET.target # id:3:initdefault: ","date":"2017-04-26","objectID":"/2017_04_26/:4:0","tags":["Linux筆記"],"title":"Linux關機命令","uri":"/2017_04_26/"},{"categories":["Linux"],"content":"退出登錄 Linux支援256個遠端登錄，Windows XP 1個、Windows Sever 2003 2個、Windows Sever 2008 4~8個 如果我們遠端登入沒有登出的話會造成下一次可能登入不了的問題，舉一個例子，如果我用Windows XP遠端登入，然後我們直接關掉，沒有登出，直接關掉終端機，在下一次登入的時候，有可能會登不進去，因為Windows XP只能一個遠端登入，所以登出是很重要的習慣。 # logout ","date":"2017-04-26","objectID":"/2017_04_26/:5:0","tags":["Linux筆記"],"title":"Linux關機命令","uri":"/2017_04_26/"},{"categories":null,"content":"Hugo 和 LoveIt 中的 Emoji 的用法指南.","date":"2017-04-15","objectID":"/2017-04-15/","tags":["CCNA"],"title":"ACL Packet Tracert Cisco CLI","uri":"/2017-04-15/"},{"categories":null,"content":"提供的檔案 簡報 Final Exam(6.0).pkt ","date":"2017-04-15","objectID":"/2017-04-15/:1:0","tags":["CCNA"],"title":"ACL Packet Tracert Cisco CLI","uri":"/2017-04-15/"},{"categories":null,"content":"要求 ","date":"2017-04-15","objectID":"/2017-04-15/:2:0","tags":["CCNA"],"title":"ACL Packet Tracert Cisco CLI","uri":"/2017-04-15/"},{"categories":null,"content":"切網段 順序 1 2 3 4 int vlan2 vlan3 vlan4 R1 切台數 64 32 16 8 網段頭 80.0 80.64 80.96 80.112 網段尾 80.63 80.95 80.111 80.119 遮罩 255.192 255.224 255.240 255.248 ","date":"2017-04-15","objectID":"/2017-04-15/:3:0","tags":["CCNA"],"title":"ACL Packet Tracert Cisco CLI","uri":"/2017-04-15/"},{"categories":null,"content":"設定 IP ","date":"2017-04-15","objectID":"/2017-04-15/:4:0","tags":["CCNA"],"title":"ACL Packet Tracert Cisco CLI","uri":"/2017-04-15/"},{"categories":null,"content":"子網段設定 [Router]$confi Configuring from terminal, memory, or network [terminal]$? Enter configuration commands, one per line. End with CNTL/Z. [Router1(config)]$ int fa0/0 [Router1(config-if)]$ no shutdown [Router1(config-if)]$ int fa0/0.1 [Router1(config-subif)]$ ip address 192.168.80.1 255.255.255.192 ","date":"2017-04-15","objectID":"/2017-04-15/:5:0","tags":["CCNA"],"title":"ACL Packet Tracert Cisco CLI","uri":"/2017-04-15/"},{"categories":null,"content":"EIGRP 設定 [Router1]$\u003e en [Router1]$ confi Configuring from terminal, memory, or network [terminal]$? Enter configuration commands, one per line. End with CNTL/Z. [Router1(config)]$ router eigrp 100 [Router1(config-router)]$ network 192.168.80.252 %DUAL-5-NBRCHANGE: IP-EIGRP 100: Neighbor 192.168.80.254 (Serial1/0) is up: new adjacency [Router1(config-router)]$ network 192.168.80.112 [Router2(config)]$ router eigrp 100 [Router2(config-router)]$ network 192.168.80.254 [Router2(config-router)]$ network 192.168.80.249 [Router2(config-router)]$ network 192.168.80.0 [Router2(config-router)]$ network 192.168.80.64 [Router2(config-router)]$ network 192.168.80.96 [Router3(config)]$ router eigrp 100 [Router3(config-router)]$ network 192.168.80.250 %DUAL-5-NBRCHANGE: IP-EIGRP 100: Neighbor 192.168.80.249 (Serial1/0) is up: new adjacency [Router3(config-router)]$ network 192.168.10.1 %DUAL-5-NBRCHANGE: IP-EIGRP 100: Neighbor 192.168.10.2 (Serial1/1) is up: new adjacency [Router3(config-router)]$ network 192.168.20.1 [Router3(config-router)]$ network 192.168.30.1 [Router3(config-router)]$ no auto-summary [Router4(config)]$ router eigrp 100 [Router4(config-router)]$ network 192.168.10.2 [Router4(config-router)]$ network 192.168.40.1 [Router4(config-router)]$ network 192.168.50.1 [Router4(config-router)]$ no auto-summary ","date":"2017-04-15","objectID":"/2017-04-15/:6:0","tags":["CCNA"],"title":"ACL Packet Tracert Cisco CLI","uri":"/2017-04-15/"},{"categories":null,"content":"Switch Trunk [Switch0]$\u003e en [Switch0]$ confi Configuring from terminal, memory, or network [terminal]$? [Switch0(config)]$ int fa0/2 [Switch0(config-if)]$ switchport mode trunk [Switch0(config-if)]$ int fa0/3 [Switch0(config-if)]$ switchport mode trunk [Switch1(config)]$ int fa0/2 [Switch1(config-if)]$ switchport mode trunk 設定Vlan、vlan name [Switch]$\u003e en [Switch]$confi Configuring from terminal, memory, or network [terminal]$? Enter configuration commands, one per line. End with CNTL/Z. [Switch(config)]$ vlan 2 [Switch(config-vlan)]$ name v2 [Switch(config-vlan)]$ vlan 3 [Switch(config-vlan)]$ name v3 [Switch(config-vlan)]$ vlan 4 [Switch(config-vlan)]$ name v4 [Switch(config-vlan)]$ int fa0/4 [Switch(config-if)]$ switchport access vlan2 [Switch(config-if)]$ switchport access vlan 2 [Switch(config-if)]$ int fa0/5 [Switch(config-if)]$ switchport access vlan 4 [Switch(config-if)]$ int fa0/6 [Switch(config-if)]$ switchport access vlan 3 到此已經完成要求2、3了。 ","date":"2017-04-15","objectID":"/2017-04-15/:7:0","tags":["CCNA"],"title":"ACL Packet Tracert Cisco CLI","uri":"/2017-04-15/"},{"categories":null,"content":"ACL 設定 30.2不能ping 50.2 [Router3]$\u003een [Router3]$ confi Configuring from terminal, memory, or network [terminal]$? Enter configuration commands, one per line. End with CNTL/Z. [Router3(config)]$ access-list 10 deny host 192.168.50.2 [Router3(config)]$ access-list 10 permit any [Router3(config)]$ int fa0/1 [Router3(config-if)]$ ip access-group 10 out ","date":"2017-04-15","objectID":"/2017-04-15/:8:0","tags":["CCNA"],"title":"ACL Packet Tracert Cisco CLI","uri":"/2017-04-15/"},{"categories":null,"content":"設定密碼 Router 自己的密碼 [Router]$\u003e en [Router]$ confi Configuring from terminal, memory, or network [terminal]$? Enter configuration commands, one per line. End with CNTL/Z. [Router(config)]$ enable secret cisco 遠端登入的密碼 [Router]$\u003e en Password: [Router]$ confi Configuring from terminal, memory, or network [terminal]$? Enter configuration commands, one per line. End with CNTL/Z. [Router(config)]$ line vty ? \u003c0-15\u003e First Line number [Router(config)]$ line vty 0 15 [Router(config-line)]$ password cisco [Router(config-line)]$ login ","date":"2017-04-15","objectID":"/2017-04-15/:9:0","tags":["CCNA"],"title":"ACL Packet Tracert Cisco CLI","uri":"/2017-04-15/"},{"categories":null,"content":"遠端登入 [Router]$ \u003een Password: [Router1]$ telnet 192.168.80.254 ## 或是192.168.80.249 Trying 192.168.80.254 ...Open User Access Verification Password: [Route2]$\u003e en Password: [Router2]$ confi Configuring from terminal, memory, or network [terminal]$? Enter configuration commands, one per line. End with CNTL/Z. [Router(config)]$ ","date":"2017-04-15","objectID":"/2017-04-15/:10:0","tags":["CCNA"],"title":"ACL Packet Tracert Cisco CLI","uri":"/2017-04-15/"},{"categories":["Linux"],"content":"Hugo 和 LoveIt 中的 Emoji 的用法指南.","date":"2017-04-03","objectID":"/2017_04_03/","tags":["Linux筆記"],"title":"Linux 文件搜索指令","uri":"/2017_04_03/"},{"categories":["Linux"],"content":"不像是Windows之類的GUI畫面都有搜索的功能，Linux的搜索命令非常的強大，這些搜索命令也比較多，至少功能比Windows強大了不知道多少。 locate 文件搜索 locate和find搜索的最大差別就是，它的搜索速度比find快了很多，find會把範圍之內的所有文件都搜索一次，如果find搜索的範圍設定的很大的話，這會是一個非常耗費資源的命令。 [root@localhost ~]# locate install.log /root/install.log /root/install.log.syslog [root@localhost ~]# touch G-3Gumdam.plist [root@localhost ~]# locate G-3Gumdam.plist ## 搜不到任何檔案 [root@localhost ~]# updatedb ## 強制更新locate的資料庫 [root@localhost ~]# locate G-3Gundam.plist /Users/Gumdam/G-3Gumdam.plist locate速度比較快，因為它只有搜尋后台數據庫的文件，後台數據庫又叫内容管理系统Content Manage System（简称CMS），這個數據庫一般會一天更新一次，在Linux裡面它的數據庫文件就在/var/lib/mlocate裡面（Linux的版本不一樣，數據庫的名字也可能會不同），若要強制更新只要運行updatedb即可。 locate的功能比較差，只能使用文件名搜索，相對於find的功能就好了很多可以用大小、名字、使用者去做搜索。 有時候locate還是查不到檔案的話有可能是locate的搜尋設定的問題，在Linux裡面設定的檔案都放在/etc目錄下面，而locate的設定檔就在/etc/updatedb.conf，而MacOS在/etc/locate.rc如下： [root@localhost ~]# vi /etc/locate.rc # /etc/locate.rc - command script for updatedb(8) # # $FreeBSD: src/usr.bin/locate/locate/locate.rc,v 1.9 2005/08/22 08:22:48 cperc$ # # All commented values are the defaults # # temp directory #TMPDIR=\"/tmp\" # the actual database #FCODES=\"/var/db/locate.database\" # directories to be put in the database #SEARCHPATHS=\"/\" # directories unwanted in output #PRUNEPATHS=\"/tmp /var/tmp\" # the actual database #FCODES=\"/var/db/locate.database\" # directories to be put in the database #SEARCHPATHS=\"/\" # directories unwanted in output #PRUNEPATHS=\"/tmp /var/tmp\" # filesystems allowed. Beware: a non-listed filesystem will be pruned # and if the SEARCHPATHS starts in such a filesystem locate will build # an empty database. # # be careful if you add 'nfs' #FILESYSTEMS=\"hfs ufs\" [root@localhost ~]# locate swtag.log ## 搜索/tmp下的檔案 ##搜尋不到任何文件 如果按照上面的規則來看我的/tmp目錄下的檔案是不會被搜索的如果我隨便搜索一個/tmp是不會被查詢的，如果我要搜索/tmp下面的檔案，我就必須修改設定檔 whereis、which 搜索系統命令介紹 whereis和which這兩個命令只能尋找系統命令的資訊，並不能尋找其他的外裝命令，比如我搜索pandoc、npm、git、pip3、brew、macport就不行使用，有些Linux查不到shell內建的指令例如：cd、bg、echo。 [root@localhost ~]# which npm #搜索一個外裝指令 # 搜不到任何東西 ","date":"2017-04-03","objectID":"/2017_04_03/:0:0","tags":["Linux筆記"],"title":"Linux 文件搜索指令","uri":"/2017_04_03/"},{"categories":["Linux"],"content":"whereis 搜索命令所在位置以及幫助文檔 whereis [command name] 選項： -b 只查找命令位置 -m 只查找man的幫助文檔位置 whereis ls ls: /bin/ls /usr/share/man/manl/ls.l.gz /usr/share/man/manlp/ls.lp.gz ","date":"2017-04-03","objectID":"/2017_04_03/:1:0","tags":["Linux筆記"],"title":"Linux 文件搜索指令","uri":"/2017_04_03/"},{"categories":["Linux"],"content":"which 搜索命令（有別名會顯示） [root@localhost ~]# which [command name] [root@localhost ~]# which ls alias ls='ls --color=auto' /bin/ls [root@localhost ~]# which pwd /bin/pwd ##不是所有命令都有別名 環境變量 由於之前提到搜索系統命令的命令是依據環境變量$PATH中的系統命令路徑做搜索的，所以就來介紹一下環境變量吧！ 環境變量這種設定在Windows上面也有，在Linux裡面如果沒有環境變量的話，那麼我使用指令的話就要使用絕對路徑才可以找到我要使用的指令，何其的麻煩，如果我要使用ls，那麼我要在終端機上面打上/bin/ls我的命令才可以執行，這是非常麻煩的，所以Linux上面如果要安裝指令在上面使用的話，就要設定環境變量，雖然Linux基本指令的環境變量在安裝時就已經設定了，但是如果我們要外裝命令的話還是要設定環境變量才行。 [root@localhost ~]# echo $PATH #查看設定的環境變量 /usr/local/bin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/opt/X11/bin:/Library/TeX/texbin [root@localhost ~]# whereis ls [root@localhost ~]# /bin/ls 檔案執行一個命令的時候，Linux上會查看$PATH下面所有的路徑，以上為例，當我使用ls命令，的時候Linux上會查看/usr/local/bin再查看/usr/local/bin，直到查到了/bin找到ls指令之後執行。 所以綜合上面所說的，如果我有一個命令想要不用絕對路徑使用的話我就要把這個命令放在$PATH$下面的目錄當中。 環境變量不可以亂刪，不管是在Linux還是Windows下，如果環境變量刪除了，會有很多的指令無法使用，用Windows舉例好了，如果改錯有可能會無法打開遊戲(⊙o⊙)哦。 當我在使用一些要新增自己寫的命令或是別人寫的命令的時候，也可以建立一個各別的路徑去分類我的命令，設定方法如下： [root@localhost ~]# export PATH=/usr/local/webserver/mysql/bin:$PATH #新增環境變量 [root@localhost ~]# echo $PATH #查看設定的環境變量 /usr/local/webserver/mysql/bin：/usr/local/bin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/opt/X11/bin:/Library/TeX/texbin #環境變量設定成功！ 當然現在很多的軟體源在安裝的時候就會幫我們設定好環境變量了，可是有時候命令無法執行，還是要會除錯才行，所以我們還是得知道一下環境變量的設定方法。 find 搜索文件命令 find命令的功能比較多、比較強大，相對的選項就會比較多，其中以下幾個是比較常用的選項。 find [directory] [option] [conditions] 選項 -name 以文件名搜索 -iname 以文件名搜索，不區分大小寫 -user 搜索該所有者的文件 -nouser 搜索不是該所有者的文件 -mtime 文件上次修改內容時間 -atime 文件上次訪問時間 -ctime 文件上次修改屬性時間 -size 以文件大小搜索文件 -inum 以inode numbr搜索文件 -a AND邏輯 -o OR 邏輯 -exec 命令 {} \\; 搜索完後再執行一個命令 ","date":"2017-04-03","objectID":"/2017_04_03/:2:0","tags":["Linux筆記"],"title":"Linux 文件搜索指令","uri":"/2017_04_03/"},{"categories":["Linux"],"content":"find / -name 以文件名搜索 [root@localhost ~]# find / -name install.log /root/install.log 在使用find命令搜索文件的時候，應該要避免大範圍搜索，所以指定的路徑盡量要小，還有一點，如果使用這種無通配符的搜索的話，我的搜索條件就要完全相符，所以如果只是要搜索特定的文件，就要使用通配符來執行搜索（其他的指令也是如此）。 ","date":"2017-04-03","objectID":"/2017_04_03/:3:0","tags":["Linux筆記"],"title":"Linux 文件搜索指令","uri":"/2017_04_03/"},{"categories":["Linux"],"content":"常用的通配符 通配符在其他的指令中也可以使用其中最長用的是*、？、[]。 * 任意內容 ? 一個字符 [] 任意刮號內的字符 [root@localhost ~]# find /root -name ly* ##搜索範圍內ly開頭的文件 /root/lyre /root/lyri /root/lyris [root@localhost ~]# find /root -name lyr? ##搜索範圍內ly后一個字符的文件 /root/lyri [root@localhost ~]# find /root -name lyr[ie] ##搜索範圍內lyr后為i或為e的文件 /root/lyre /root/lyri [root@localhost ~]# find /root -name *[ie] ##搜範圍內索結尾為i或是為e的文件 /root/lyre /root/lyri [root@localhost ~]#find ~/Desktop/Tools -name \"*\" ##搜索範圍內所有文件 /Users/Gumdam/Desktop/Tools /Users/Gumdam/Desktop/Tools/.DS_Store /Users/Gumdam/Desktop/Tools/EFI Patch /Users/Gumdam/Desktop/Tools/EFI Patch/efi64_31348.bin /Users/Gumdam/Desktop/Tools/EFI Patch/SnowLeo.tool /Users/Gumdam/Desktop/Tools/SwitchVersion.tool [root@localhost ~]# find /root -name lyris* 在上面的命令中其中-name \"*\"的搜索中是包含隱藏文件的，例如.DS_Store就是隱藏文件。 ","date":"2017-04-03","objectID":"/2017_04_03/:3:1","tags":["Linux筆記"],"title":"Linux 文件搜索指令","uri":"/2017_04_03/"},{"categories":["Linux"],"content":"find / -iname 以文件名搜索，不區分大小寫 [root@localhost ~]# find / -name InStAlL.log find: InStAlL.log: No such file or directory [root@localhost ~]# find / -iname InStAlL.log /root/install.log 在Linux上面是嚴格區分大小寫的，所以當我搜索文件的時候，如果搜索的關鍵字，我想要大小寫的內容都搜索的話，我就要使用-iname了，用這個指令搜索的內容都不會區分大小寫。 ","date":"2017-04-03","objectID":"/2017_04_03/:4:0","tags":["Linux筆記"],"title":"Linux 文件搜索指令","uri":"/2017_04_03/"},{"categories":["Linux"],"content":"find / -user 以文件所有者搜索 [root@localhost ~]# find /root -user root /root /root/.bashrc /root/.tcshrc /root/.bash_history /root/.lesshst /root/.bash_profile /root/install.log /root/.bash_logout /root/install.log.syslog /root/.cshrc ","date":"2017-04-03","objectID":"/2017_04_03/:5:0","tags":["Linux筆記"],"title":"Linux 文件搜索指令","uri":"/2017_04_03/"},{"categories":["Linux"],"content":"find / -nouser 以文件所有者搜索不是該所有者的文件 [root@localhost ~]# find /root -nouser root /root/Gumdam.out [root@localhost ~]# find /root -nouser -exec rm -rf {} \\; #搜索並且刪除所有沒有所有者的文件 在Linux中沒有所用者的文件是垃圾文件，所以一般應該是要手動刪除的，但是有兩個狀況是例外，要特別注意。 第一個情況是Linux的內核產生的文件，內核在執行的過程中是不會經過所用者的，所以內核產生的文件是不會有所用者的，內核的運行過程中會在內存記憶體之中交互作用，所以在/proc和/sys目錄下面是會產生沒有檔案所用者的文件的。 第二個情況是在Windows上面建立的文件，在這個Windows盛行的時代，我們難免會使用到Windows上面建立的文件，在Windows建立文件的時候是會忽略檔案所用者的，所以如果你用USB隨身碟把你的文件拿到Linux上面作業，你之前在Windows上面建立的文件是沒有所用者的，所以不能刪除。 Linux上面除了以上兩種文件，大多都是可以直接手動刪除的。 ","date":"2017-04-03","objectID":"/2017_04_03/:6:0","tags":["Linux筆記"],"title":"Linux 文件搜索指令","uri":"/2017_04_03/"},{"categories":["Linux"],"content":"find / -mtime 搜索文件上次修改文件內容的時間 [root@localhost ~]# find /var/log -mtime +10 其中10代表天數，如果加上正負號的話，+10代表我要查找十天之前修改的文件、10代表十天當天修改的文件、-10代表十天內修改的文件。 ","date":"2017-04-03","objectID":"/2017_04_03/:7:0","tags":["Linux筆記"],"title":"Linux 文件搜索指令","uri":"/2017_04_03/"},{"categories":["Linux"],"content":"find / -atime 搜索文件上次訪問的時間 [root@localhost ~]# find /var/log -atime +10 ","date":"2017-04-03","objectID":"/2017_04_03/:8:0","tags":["Linux筆記"],"title":"Linux 文件搜索指令","uri":"/2017_04_03/"},{"categories":["Linux"],"content":"find / -ctime 搜索文件上次修改文件屬性的時間 [root@localhost ~]# find /var/log -ctime +10 ","date":"2017-04-03","objectID":"/2017_04_03/:9:0","tags":["Linux筆記"],"title":"Linux 文件搜索指令","uri":"/2017_04_03/"},{"categories":["Linux"],"content":"find / -size 以文件大小搜索文件 [root@localhost ~]# find . -size 25k 和之前的天數的命令一樣，如果我輸入25k是搜索等於25KB的文件、輸入-25k是搜索小於25KB的文件、輸入+25k是搜索大於25KB的文件， find ~/Desktop -size -25K find: -size: -25K: illegal trailing character 其中有些要小心的地方是單位的大小寫，如果KB的K輸入成大小的話，Linux是便是不出來的，因為Linux是嚴格區分大小寫的。 大部分使用到的是KB以及MB，這兩個只要分別寫成k、M即可。 find ~/Desktop -size -25 如果不寫單位的預設的單位是磁碟扇區，一個扇區，扇區是一個邏輯的概念，並不是真實存在的東西，在這個指令上一個扇區有512KB的大小，所以上面指令是搜索$512KB \\times25大小的文件$，這是非常不人性化的使用方式，所以一般不是用它，知道就可以了。 如下圖A為磁軌、B為幾何扇區、C為磁軌扇，相鄰磁區組合在一起，組成D叢集，磁區的排列由格式化成的檔案系統來決定，在Linux的ex4檔案系統中，會把硬碟每4KB切成一個區塊、每512KB切成一個扇區。 ","date":"2017-04-03","objectID":"/2017_04_03/:10:0","tags":["Linux筆記"],"title":"Linux 文件搜索指令","uri":"/2017_04_03/"},{"categories":["Linux"],"content":"find / -inum 以inode numbr搜索文件 [root@localhost ~]# find / -inum 262223 這個指令會搜索inode number為262223的文件，inode number在之前已經提過了所以不再多做解釋。 ","date":"2017-04-03","objectID":"/2017_04_03/:11:0","tags":["Linux筆記"],"title":"Linux 文件搜索指令","uri":"/2017_04_03/"},{"categories":["Linux"],"content":"find 下的-a和-o [root@localhost ~]# find /etc -size +32k -a -mtime -10 ## 搜索/etc 目錄下大於32KB且十天內有修改過內容的文件 [root@localhost ~]# find /etc -size +32k -o -mtime -10 ## 搜索/etc 目錄下大於32KB或十天內有修改過內容的文件 ","date":"2017-04-03","objectID":"/2017_04_03/:12:0","tags":["Linux筆記"],"title":"Linux 文件搜索指令","uri":"/2017_04_03/"},{"categories":["Linux"],"content":"find 搜索後面加上 -exec 命令 {} \\; find [directory] [Option] [condition] -exec [command] {} \\; 這個命令代表把find命令的搜尋結果用-exec後面的命令去處理，其中-exec [command] {} \\;是通用格式，是要記起來的。 [root@localhost ~]# find /etc -size +32k -exec ls -lh {} \\; ## 列出/etc目錄下面大於32KB的檔案 [root@localhost ~]# find /etc -nouser -exec rm -rf {} \\; ## 搜索/etc 目錄下沒有所有者的文件，然後全部刪除 這個格式只可以在find命令下使用，如果在其他命令下面使用會報錯： [root@localhost ~]# ll ~/Desktop/te.md -exec mv ~ {} \\; ls: -exec: No such file or directory ls: mv: No such file or directory ls: {};: No such file or directory -rw-r--r--@ 1 Gumdam staff 21K 3 16 19:25 /Users/Gumdam/Desktop/te.md /Users/Gumdam: total 1032 drwx------+ 33 Gumdam staff 1.1K 3 17 00:22 Desktop drwx------+ 32 Gumdam staff 1.1K 3 15 18:46 Documents -rw-r--r-- 1 Gumdam staff 9.6K 3 7 21:08 vimrc grep 搜索文件中字符串命令 grep [OPTIONS] PATTERN [FILE…] 選項 -i 不區分大小寫查詢 -v 排除指定字串 ","date":"2017-04-03","objectID":"/2017_04_03/:13:0","tags":["Linux筆記"],"title":"Linux 文件搜索指令","uri":"/2017_04_03/"},{"categories":["Linux"],"content":"grep / -i [root@localhost ~]# grep \"net\" anaconda-ks.cfg network --bootproto=dhcp --device=ens33 --ipv6=auto --activate network --hostname=localhost.localdomain [root@localhost ~]# grep -i \"net\" anaconda-ks.cfg # Network information network --bootproto=dhcp --device=ens33 --ipv6=auto --activate network --hostname=localhost.localdomain Linux是會區分大小寫的，如果想要大小寫全部搜尋就要加上-i。 ","date":"2017-04-03","objectID":"/2017_04_03/:14:0","tags":["Linux筆記"],"title":"Linux 文件搜索指令","uri":"/2017_04_03/"},{"categories":["Linux"],"content":"grep / -v [root@localhost ~]# echo maplestory is great game \u003e\u003e info.log [root@localhost ~]# grep -v maplestory info.log [root@localhost ~]# echo you lose \u0026\u003e\u003e info.log [root@localhost ~]# cat info.log maplestory is great game you lose [root@localhost ~]# grep -v \"maplestory\" info.log you lose 如果我們要搜索除了含有某個字串以外的內容的話，我們可以使用-v，上面的例子中，我搜索沒有maplestory部分的內容，在第二行我的搜索沒有任何內容是因為grep查詢是查詢一整句話，我的內容就只有一句話，而除了這句話以外，我沒有其他的內容了，所以沒有查詢結果。 ","date":"2017-04-03","objectID":"/2017_04_03/:15:0","tags":["Linux筆記"],"title":"Linux 文件搜索指令","uri":"/2017_04_03/"},{"categories":["Linux"],"content":"Hugo 和 LoveIt 中的 Emoji 的用法指南.","date":"2017-03-27","objectID":"/2017_03_27_3/","tags":["Linux筆記"],"title":"Linux鍵結指令","uri":"/2017_03_27_3/"},{"categories":["Linux"],"content":"ln [option] [source file] [target file] 選項 -s 建立軟鏈接 鏈接指令分為硬鏈接和軟連接，沒有加上任何選項，軟鏈接要加上-s ","date":"2017-03-27","objectID":"/2017_03_27_3/:0:0","tags":["Linux筆記"],"title":"Linux鍵結指令","uri":"/2017_03_27_3/"},{"categories":["Linux"],"content":"硬鏈接 硬鏈接的特征 硬鏈接和原本文件有相同的inode number和儲存區塊，可以看做是同一個文件 可以通過inode number找尋檔案 不能跨分區 不能針對目錄使用 ","date":"2017-03-27","objectID":"/2017_03_27_3/:1:0","tags":["Linux筆記"],"title":"Linux鍵結指令","uri":"/2017_03_27_3/"},{"categories":["Linux"],"content":"軟鏈接 軟連接特征： 類似Windows快捷方式 軟連接有自己的inode number和儲存區塊，但是自己的數據區塊裡面只有儲存原檔的inode number以及儲存區塊 軟鏈接的權限都為lrwxrwxrwx 修改任意文件，另一個文件會更動 原始檔刪了，軟鏈接失效 [root@localhost~/Desktop]# touch Gumdam00 # 建立一個空文件 [root@localhost~/Desktop]# ll total 0 -rw-r--r-- 1 Gumdam staff 0B 3 11 23:07 Gumdam00 [root@localhost/]# ln /Gumdam00 /WinGumdam.hard ## 建立硬鏈接 .hard [root@localhost/]# ll total 0 -rw-r--r-- 2 Gumdam staff 0B 3 11 23:07 Gumdam00 -rw-r--r-- 2 Gumdam staff 0B 3 11 23:07 WinGumdam.hard ## 硬鍵接會增加引用計數 [root@localhost/]# ln -s /Gumdam00 /GumdamDeathscythe.bak ## 建立軟連接 .bak [root@localhost/]# ll total 16 -rw-r--r-- 2 Gumdam staff 0B 3 11 23:07 Gumdam00 lrwxr-xr-x 1 Gumdam staff 8B 3 11 23:10 GumdamDeathscythe.bak -\u003e Gumdam00 -rw-r--r-- 2 Gumdam staff 0B 3 11 23:07 WinGumdam.hard ## 軟鏈接不會增加引用計數 [root@localhost~/]# ln /WinGumdam.hard /GumdamHeavyarms.hard # 建立硬鏈接 [root@localhost~/]# rm /WinGumdam.hard # 刪除原始檔 [root@localhost~/]# open /GumdamHeavyarms.hard ## 硬鏈接沒有原文件還可以開 [root@localhost/]# ln -s /GumdamHeavyarms.hard /GumdamSandrock.bak # 建立軟鏈接 [root@localhost/]# rm /GumdamHeavyarms.hard [root@localhost/]# open /GumdamSandrock.bak The file /Users/Gumdam/Desktop/Gumdam/GumdamSandrock does not exist. ## 軟鏈接沒有原文件失效 軟鏈接有一個很重要的重點，路徑一定要寫絕對路徑，不然兩個檔案在不同目錄之下你的軟鏈接接是會找不到檔案的，寫絕對路徑是最好的，由於硬鏈接都有相同的inode number所以在不同目錄還是可以打開。 [root@localhost~/Desktop]# pwd /Users/Gumdam/Desktop [root@localhost~/Desktop]# ln -s /Users/Gumdam/Desktop/lyris lyris1 [root@localhost~/Desktop]# ln -s lyris lyris2 [root@localhost~/Desktop]# cat lyris2 #使用絕對路徑軟鏈接 同目錄打開 オルフェンズ　涙　愛は悲しみを背負い　強くなれるから [root@localhost~/Desktop]# ln lyris lyris3 [root@localhost~/Desktop]# mv lyris* ~ #將lyris1、2、3 移動到~目錄 [root@localhost~/Desktop]# cd ~ [root@localhost~/Desktop]# cat lyris1 #使用絕對路徑軟鏈接 搬移後打開 オルフェンズ　涙　愛は悲しみを背負い　強くなれるから [root@localhost~/Desktop]# cat lyris2 #使用相對路徑軟鏈接 搬移後打開 cat: lyris2: No such file or directory [root@localhost~/Desktop]# cat lyris3 #使用相對路徑硬鏈接 搬移後打開 オルフェンズ　涙　愛は悲しみを背負い　強くなれるから 如果在練習指令的時候視窗的東西太亂，可以使用clear指令清空目前視窗上打過的指令，或是使用快捷鍵 Ctrl+L 如果是使用GUI界面的Linux，一般也會有很多很多圖形界面的軟體，鏈接的指令可以使用在安裝.AppImage文件的時候，如果要製作鍵結在桌面可以向下面安裝，.AppImage的檔案一般是不會有鏈接的，每次要使用都要去找檔案目錄的位置非常麻煩，。 [root@localhost~/Desktop]# cd ~/Downloads [root@localhost~/Desktop]# chmod u+x MuseScore*.AppImage [root@localhost~/Desktop]# ln -s MuseScore*.AppImage ~/Desktop 講到軟體安裝，就順便說一下debian的系統常常使用.deb的軟體包（Debian軟體包）的格式，細部的內容可以參考dpkg使用筆記： [root@localhost~/Desktop]# dpkg -i teamviewer*.deb ##安裝軟體包 [root@localhost~/Desktop]# dpkg -r teamviewer*.deb ##移除軟體包 ","date":"2017-03-27","objectID":"/2017_03_27_3/:2:0","tags":["Linux筆記"],"title":"Linux鍵結指令","uri":"/2017_03_27_3/"},{"categories":["Linux"],"content":"Hugo 和 LoveIt 中的 Emoji 的用法指南.","date":"2017-03-27","objectID":"/2017_03_27_2/","tags":["Linux筆記"],"title":"Linux目錄指令","uri":"/2017_03_27_2/"},{"categories":["Linux"],"content":"mkdir 目錄創建 mkdir [option] [parameter] 選項 -p遞歸創建（創建/Gumdan/...） [root@localhost~]#mkdir ~/Desktop/Gumdan [root@localhost~]# mkdir ~/Desktop/Gumdan/season mkdir: /Users/Gumdam/Desktop/Gumdan: No such file or directory [root@localhost~]# mkdir -p ~/Desktop/Gumdan/season 當要創建/Gumdan/season的時候/Gumdan不存在的話要是用-p才可以進行創建。 ","date":"2017-03-27","objectID":"/2017_03_27_2/:1:0","tags":["Linux筆記"],"title":"Linux目錄指令","uri":"/2017_03_27_2/"},{"categories":["Linux"],"content":"cd 切換目錄 簡化指令 功能 cd / 進入根目錄 cd ~ 進入家目錄 cd 進入家目錄 cd - 進入上一次目錄（切換前） cd .. 進入上一級目錄 cd . 進入當前目錄（沒有用） 可以利用pwd查看自己的目錄位置，cd值得一說的一點是它是shell原本內建（自帶）的命令，可以使用搜索指令查詢得知： [root@localhost~]# which cd cd: shell built-in command 除了cd是shell自帶命令以外，其實還有很多指令是自帶的，例如：alias、bg、fg、echo 使用cd指令的時候需要考慮路徑的問題，路徑分為相對路徑和絕對路徑，相對路徑是參照目前目錄位置去執行的路徑，絕對路徑是則可以因為不用參照路徑，所以可以在任何目錄中執行。 相對路徑 絕對路徑 ../usr/local/src /usr/local/src [root@localhost~]# pwd /root # 參照目錄為 /root [root@localhost~]# cd ../usr/local/src [root@localhost src]# pwd /usr/local/src ## 參照目錄為 /usr/local/src [root@localhost~]# cd ../usr/local/src cd: no such file or directory: ../usr/local ## 無法辨認 /usr、/local [root@localhost src]# cd /usr/local/src ## 絕對路徑可以在任何位置使用 相對路徑要注意一點，當我當前目錄位置發生變化，原本可以執行的命令，就有可能不能執行，相對的絕對路徑就不會有這個問題，所以使用網路上面複製的指令時，要特別注意路徑是否正確。 在Linux當中有Tab補全的功能，建議使用Tab避免打字錯誤的狀況發生，在一些發行版本作業系統雖然指令使用方法雖然相同，但是可能會有一些小問題，比如我在Mac OS裡面的空格（blank space）在終端機上會顯示為\\，所以在不使用Tab的狀況之下，打錯的可能性很高，使用Tab可以減少不必要的錯誤。 [root@localhost ~/Desktop]# cd ## 按下 Tab 鍵會出現下方補全 \\$RECYCLE.BIN/ Project.logicx/ Tools/ icircuit/ Gumdan/ Rmd\\ to\\ pptx/ cpp\\ text/ [root@localhost ~/Desktop]# cd Rmd\\ to\\ pptx/ ##按 Tab 選出要的 ","date":"2017-03-27","objectID":"/2017_03_27_2/:2:0","tags":["Linux筆記"],"title":"Linux目錄指令","uri":"/2017_03_27_2/"},{"categories":["Linux"],"content":"rm 刪除文件或是目錄 rm [option] [file or directory] 選項： r 刪除目錄 f 強制刪除 [root@localhost ~/Desktop]# mkdir abc [root@localhost ~/Desktop]# rm abc rm: abc: is a directory [root@localhost ~/Desktop]# rm -r abc rm: remove directory 'abc'? n [root@localhost ~/Desktop]# rm -rf abc 在Linux上面的rm指令不是Windows上面的刪除，它並不會把檔案送到回收桶，你刪了他就消失了，一般在使用rm指令的時候都會直接使用rm -rf來刪除檔案，因為刪除目錄的時候要有-r、不加-f的話有會被問是否刪除，所以一般常用rm -rf。 [root@localhost ~/Desktop]# rm -rf / rm有一個要小心的地方，上面的這個指令真的不要打上去，這個指令會讓系統99%的數據被刪除，但是系統並不會崩潰，如果沒有raid陣列或是其他的保護檔案的措施的話文件是無法還原的，說簡單一點數據恢復牽涉的條件非常的廣，要盡量避免這種事情發生。 這是讓Linux自殺的指令，但是Linux卻會不誤的去執行它，令人不安心的是，在輸入路徑的時候這個是很可能不小心出現的錯誤，但是這也側面說明了在Linux上面使用者擁有很高的系統權限。 [root@localhost /]# rm -rf /bin [root@localhost /]# rm -rf /bin/* 使用rm -rf的時候還要注意一個地方不要刪錯一些系統目錄或是系統的掛載點，上面的指令中的/bin/*是指/bin目錄下面的內容，這個指令如果刪除/bin的話會刪除/bin這個系統目錄，這個是我們不希望發生的，如果刪除了像是/proc、/sys之類的掛在點可能就出大事情了。 ","date":"2017-03-27","objectID":"/2017_03_27_2/:3:0","tags":["Linux筆記"],"title":"Linux目錄指令","uri":"/2017_03_27_2/"},{"categories":["Linux"],"content":"cp 複製指令 cp [option] [source file] [target file] 選項 -r 複製目錄 -p 連帶文件屬性一起複製 -d 如果複製的文件是鏈接文件，複製鏈接屬性 -a 相當於 -pdr 全部，一般使用-a [root@localhost~]# cp install.log /tmp # 沒寫檔案名稱會原名複製 [root@localhost~]# cp install.log /tmp/knps # 複製后為knps [root@localhost~]# cp Gumdan ~/Desktop # 要複製目錄要使用 -r cp: Gumdan is a directory (not copied). [root@localhost~]# cp -r Gumdan ~/Desktop # 保險一點使用 -a 在使用cp指令的時候，如果只有給目標目錄位置，沒有給檔案名稱的話cp指令會原名複製。 ","date":"2017-03-27","objectID":"/2017_03_27_2/:4:0","tags":["Linux筆記"],"title":"Linux目錄指令","uri":"/2017_03_27_2/"},{"categories":["Linux"],"content":"cp -a [root@localhost~/Desktop]# date 2017年 3月 9日 周四 21時03分15秒 CST [root@localhost~/Desktop]# ll a.out -rwxr-xr-x 1 Gumdam staff 15K 3 6 21:51 a.out [root@localhost~/Desktop]# cp a.out ~ [root@localhost~/Desktop]# cp -a a.out ~/b.out [root@localhost~]# cd ~ [root@localhost~]# find *.out -exec ls -lh {} \\; -rwxr-xr-x 1 Gumdam staff 15K 3 9 21:13 a.out -rwxr-xr-x 1 Gumdam staff 15K 3 6 21:51 b.out 如果單只是使用cp的話其他的屬性是不會被複製的例如日期、鏈接…，所以只要記得使用-a就可以了。如上面的指令有使用-a複製出來的文件日期是3月6日，而沒有使用的話，日期就是今天的日期。 ","date":"2017-03-27","objectID":"/2017_03_27_2/:4:1","tags":["Linux筆記"],"title":"Linux目錄指令","uri":"/2017_03_27_2/"},{"categories":["Linux"],"content":"mv 搬移指令 mv [file or directory] [target directory] [root@localhost~/Desktop]# mv -r Gumdan mv: illegal option -- r usage: mv [-f | -i | -n] [-v] source target mv [-f | -i | -n] [-v] source ... directory [root@localhost~/Desktop]# mv Gumdam ~ mv和之前的rm還有cp不一樣，需要注意的之有它搬移目錄的時候不需要也不行使用-r，這個是因為Linux是分散式的開發，所以會有這種開發上面是有興趣人去開發的，所以有些指令會有這種選項不一的問題存在。 ","date":"2017-03-27","objectID":"/2017_03_27_2/:5:0","tags":["Linux筆記"],"title":"Linux目錄指令","uri":"/2017_03_27_2/"},{"categories":["Linux"],"content":"Linux 目錄功用 [root@localhost~/Desktop]# cd / [root@localhost~/Desktop]# ls bin cgroup etc lib media mnt opt root selinux sys usr boot dev home lost+found misc net proc sbin srv tmp var [root@localhost~/Desktop]# cd /usr [root@localhost~/Desktop]# ls bin etc games include lib libexec local sbin share src tmp [root@localhost~/Desktop]# 根目錄和/usr目錄中的/bin目錄和/sbin是用來儲存系統命令用的目錄，/boot目錄是放開機啟動數據的，/dev目錄裡面放的是硬體相關的文件，這幾個文件沒事不用去動它，裡面是一般的使用者用不到的內容，其中/bin和/sbin的區別就是/bin儲存一般使用者的指令，是所有使用這都可以使用的指令、/sbin儲存超級使用者的指令。 /etc目錄儲存系統的一些設定檔案，是很常用到的目錄。 /home普通使用者的家目錄。 /root是最高權限使用者的家目錄。 /lib是Linux函數庫儲存的目錄，在Linux裡面啟動的時候所有函數都加載的話，啟動和執行的速度將會無比的緩慢，所以會把一些不常使用的函數庫放在/lib裡面要是用的時候再調用，不使用就算了。 /mnt、/media、/misc是Linux準備的三個掛載目錄，這三個目錄只要是空目錄就可以了，是留給使用者掛載設備用的，三個都可以使用，但是大部分人一般只使用/mnt，因為在比較早的Linux裡面只有/mnt這個掛載目錄。 /sys、/proc是儲存內存數據資料的，是內存記憶體的掛載點，是不能直接操作的，我們是不能在裡面寫資料的，第一，如果重新啟動會資料丟失、第二，如果丟太大的檔案記憶體又不夠，會系統崩潰。 /var儲存特定於此系統的可變數據，在系統啟動之間保持永久性。動態變化文件（如：資料庫、緩存目錄、日誌文件、印表機後台處理文檔和網站內容等）。 一般可以隨便放檔案的目錄只有三個/home、/root、/tmp，其他的目錄如果不清楚就不要去動它，還有不建議把所有的檔案儲存在根目錄/下面，就像是把檔案全部放在Windows的桌面一樣，在使用上根目錄是非常常訪問的目錄，為操作方便，不要把所有的檔案放在根目錄。 ","date":"2017-03-27","objectID":"/2017_03_27_2/:6:0","tags":["Linux筆記"],"title":"Linux目錄指令","uri":"/2017_03_27_2/"},{"categories":["Linux"],"content":"Hugo 和 LoveIt 中的 Emoji 的用法指南.","date":"2017-03-27","objectID":"/2017_03_27/","tags":["Linux筆記"],"title":"Linux命令基本格式","uri":"/2017_03_27/"},{"categories":["Linux"],"content":" [root@localhost~]# 其中表示意義如下表： 標記 意義 root： 當前登錄的目錄 localhost 主機名稱 ~ 家目錄（這個位置放當前所在目錄） # 表示超級用戶（普通用戶為$） ","date":"2017-03-27","objectID":"/2017_03_27/:0:0","tags":["Linux筆記"],"title":"Linux命令基本格式","uri":"/2017_03_27/"},{"categories":["Linux"],"content":"pwd [root@localhost~]# pwd pwd指令可以顯示當前的絕對路徑，所以如果我在~的目錄下面使用pwd的話，用該要顯示/root/home/這個家目錄才對。 ","date":"2017-03-27","objectID":"/2017_03_27/:0:1","tags":["Linux筆記"],"title":"Linux命令基本格式","uri":"/2017_03_27/"},{"categories":["Linux"],"content":"命令格式 命令 [option] [parameter] 其中選項（Option）又分為簡化選項和完整選項比如ls中的簡化選項-a的完整選項就是--all，簡化選項和完整選項的功能是一樣的。 ls [Option] [file or directory] 選項： -a 顯示所有文件，包括隱藏文件 -l 顯示詳細訊息 -d 查看目錄屬性 -h 人性化的顯示文件大小（2023389-\u003e1.9M） -i 顯示inode number ","date":"2017-03-27","objectID":"/2017_03_27/:0:2","tags":["Linux筆記"],"title":"Linux命令基本格式","uri":"/2017_03_27/"},{"categories":["Linux"],"content":"ls -a [root@localhost~]# ls -a anaconda-ks.cfg .bash_profile .cshrc Linux裡面(.)開頭的文件就是隱藏文件，這個指令下了之後會顯示所有文件，包括隱藏的文件，在上面的範例之中.cshrc就是隱藏文件。 ","date":"2017-03-27","objectID":"/2017_03_27/:0:3","tags":["Linux筆記"],"title":"Linux命令基本格式","uri":"/2017_03_27/"},{"categories":["Linux"],"content":"ls -l [root@localhost~/Desktop]# ls -l -rwxrwxrwx@ 1 root staff 7056122 8 11 2015 the-swift.pdf drwxr-xr-x 4 root staff 136 3 8 20:21 Rmd to pptx #權限 #軟連接次數 #所文件用者 ##檔案大小 ##日期 ##檔案名稱 #引用計數 ##檔案大小不人性化 權限 -rw–r–r– 在說權限之前，要先比較一下Linux和Windows之間文件類型，Linux不像是Windows有明顯區分擴展名，Linux的軟體、硬體都是以文件形式儲存的，不管是目錄、設備…都是以文件的方式儲存的，他們的差別就只有權限。 權限默認一般有十位的字，其中第一位-為文件類型，文件類型最常見的有三個分別是文件-、目錄d、軟連接文件l，後面九個數字分別代表各種用戶所持有的權限，每三位數為一組，分別為檔案擁有者、加入此群組之帳號的權限、非本人且沒有加入本群組之其他帳號的權限，簡略的說有三個組：u所屬者、g所屬組、o其他人，而顯示的字符有讀（r）、寫（w）、執行（x）三種權限。 權限說白了就是文件和用戶之間的關係，明確各個身份所持有的權限（讀、寫、執行） 其實文件類型除了這些以外還有四種文件類型塊設備文件b、字符設備文件c、套接字文件s、管道文件p，但是並不常用只要大概知道就可以了，因為這些內容不需要普通用戶做操作。 最近的Linux權限有時候在十個位數後面會有一個(.),例如：-rw–r–r–.，這個(.)官方並沒有明確定義，但是在使用經驗上面知道這個大概是代表（ACL權限），除此之外在Mac OS上面甚至還有@，例如：-rw-r–r–@，這些類型大概知道一下就可以了。 - rw- r– r– -、d、l u所屬者 g所屬組 o其他人 ","date":"2017-03-27","objectID":"/2017_03_27/:0:4","tags":["Linux筆記"],"title":"Linux命令基本格式","uri":"/2017_03_27/"},{"categories":["Linux"],"content":"ls -d [root@localhost~/Desktop]# ls -d . [root@localhost~/Desktop]# ls -ld drwxr-xr-x+ 53 Gumdam staff 1802 3 11 16:46 . -d這個選項單獨使用時是沒有意義的，因為ls -l並沒有辦法顯示當前目錄的資料，因為我的Desktop沒有檔案，所以沒有任何的資訊，Linux當中目錄也是檔案，而這個檔案的權限我們無法得知，而這個-d可以讓我們可以查看目錄的屬性。 ","date":"2017-03-27","objectID":"/2017_03_27/:0:5","tags":["Linux筆記"],"title":"Linux命令基本格式","uri":"/2017_03_27/"},{"categories":["Linux"],"content":"ls -h [root@localhost~/Desktop]# ls -h Adlm Downloads Untitled-figure Applications Library Untitled.Rpres [root@localhost~/Desktop]# ls -lh \\dev crw------- 1 root wheel 13, 1 3 7 21:10 afsc_type5 crw-rw-rw- 1 root wheel 18, 1 3 7 21:10 cu.Bluetooth-Incoming-Port brw-r----- 1 root operator 1, 0 3 7 21:10 disk0 brw-r----- 1 root operator 1, 1 3 7 21:10 disk0s1 brw-r----- 1 root operator 1, 3 3 7 21:10 disk0s2 brw-r----- 1 root operator 1, 2 3 7 21:10 disk0s3 ### ....etc ###權限 ##檔案大小人性化 -h這個選項單獨使用時是沒有什麼意義的，因為這個選項是讓我的ls指令中的內容可以人性化的顯示檔案大小，但是單是在ls -h這個指令下面並不會有檔案大小所以使用的效果和ls是一樣的。 ","date":"2017-03-27","objectID":"/2017_03_27/:0:6","tags":["Linux筆記"],"title":"Linux命令基本格式","uri":"/2017_03_27/"},{"categories":["Linux"],"content":"ls -lh 等於 ll ## ls -lh 等同 ll [root@localhost~]# ls -lh [root@localhost~]# ll 這兩個指令是等同的，可以使用搜索指令去查ll會顯示如下： ## which 查詢命令的別名（wereis 可查詢命令、幫助文檔的位置） [root@localhost~]# which ll ll: aliased to ls -lh 除了這個樣子查詢以外，還可以使用alias透過指令的別名查詢指令指令的全名，比如我看到一個叫做gstd的指令，我不知道它是什麼指令，我就可以使用alias來查詢： [root@localhost~]# alias _ _=sudo ","date":"2017-03-27","objectID":"/2017_03_27/:0:7","tags":["Linux筆記"],"title":"Linux命令基本格式","uri":"/2017_03_27/"},{"categories":["Linux"],"content":"ls -i [root@localhost~]# ls -i ~/Desktop 3355431 $RECYCLE.BIN 454344 -the-swift-programming-language-.pdf 4753760 Orphans no Namida.mp3 453557 Command_line.pdf #inode number #filename inode number 介紹 Unix的時候，利用inode來取資料的方式就已經有了，在Linux上面也是使用這種資料查找資料，在Linux上面每一個檔案都有一個inode number，就大家所知道的檔案儲存在硬碟的位置是不固定的，首先，假設你的硬碟被格式化成了ex4檔案系統，會建立一個inocde table查找表，你的硬碟被切成了好幾個等大小的數據塊，每一個數據塊可以儲存4KB的檔案，如果我有一個10KB的檔案儲存了進去，它並不會連續的儲存，假設它分別儲存了4KB在Proc A、4KB在Proc B、2KB在Proc C。 講到這裡有一個問題，我這個10KB的文件儲存了進去有一個區塊只有儲存2KB的資料，那麼這個區塊還可以儲存其他的資料嗎？答案是不行的，有興趣可以自己去研究，數據塊不是只能切成每4KB一個區塊，默認是4KB，但是其實是可以0KB、2KB、4KB三種的。 在查找表裡面會記錄inode number（ID號碼）、修改時間、權限以及要抓資料的區塊位置。Linux中檔案在開啟的時候就是利用這個概念去抓資料的，首先讀取到inode number，再確認權限，如果不匹配就直接拒絕，匹配的話就會把數據塊中的資料抓給使用者使用。 Linux 讀取檔案過程示意圖\r","date":"2017-03-27","objectID":"/2017_03_27/:0:8","tags":["Linux筆記"],"title":"Linux命令基本格式","uri":"/2017_03_27/"},{"categories":null,"content":"Hello Ha~ ","date":"2019-08-02","objectID":"/about/:0:0","tags":null,"title":"關於 shihchun","uri":"/about/"}]